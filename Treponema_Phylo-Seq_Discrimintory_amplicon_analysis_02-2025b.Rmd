---
title: "R Notebook - Defining lineage/sublineage discriminatory sites for Treponema AmpliSeq"
output: html_notebook
---

Make a clean environment
```{r}
 rm(list=ls())
```

Load dependencies
```{r}
packages.list <- c("ggplot2","dplyr","tidyverse","treeio","ggtree","phytools","readxl","ggnewscale","ape","adegenet","pegas","mmod","vcfR","hierfstat","network","ggnetwork","intergraph","igraph", "seqinr","IRanges","ggbeeswarm","primerTree","taxize","cowplot","ggstance","ggforce","vegan","Polychrome","ggrastr","treemapify","treespace","reshape2","doMC", "pairsnp")

for(pkg in packages.list){ eval(bquote(library(.(pkg)))) }
```

Confirm current environmental setup
```{r}
R.Version()
print(sessionInfo())
```
\
\
Set shortcuts
```{r}
y.theme.strip <- theme(axis.title.y = element_blank(), axis.text.y = element_blank(), axis.ticks.y= element_blank())
y.theme.strip.partial <- theme(axis.text.y = element_blank(), axis.ticks.y= element_blank())

x.theme.strip <- theme(axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x= element_blank())
x.theme.strip.partial <- theme(axis.text.x = element_blank(), axis.ticks.x= element_blank())
x.theme.strip.labs <- theme(axis.text.x = element_blank(), axis.title.x = element_blank())

x.theme.axis.rotate <- theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
x.theme.axis.rotate.angle <- theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

y.facet.text.rotate <- theme(strip.text.y=element_text(angle=0))

legend.strip <- theme(legend.position = "none")
legend.size <- theme(legend.key.size = unit(0.55,"line"))

standard.textsize <- 10
text.size.within <- (5/14)*(standard.textsize-2)
panel.lab.size <- 10

theme.text.size <- theme(text = element_text(size = standard.textsize))

'%notin%' <- Negate('%in%')
```

\
## Define working directories
\
```{r}
print(paste("Working directory:", getwd() ))

Data_input_directory <- paste0(getwd(), "/data/")

Figures_directory <- paste0(getwd(), "/figures/")
Ancillary_Figures_directory <- paste0(getwd(), "/ancillary_figures/")
```

\
## Define input files
\
```{r}
#############################################
# Working dataset for Phylo-Seq design

# SNP alignment
TPAE.SNPaln.file <- paste0(Data_input_directory,"TPAE.all.gubbins-filtered.SNPs.aln")

# WGS alignment converted to vcf (using snp-sites)
TPAE.SNPsVCF.file <- paste0(Data_input_directory,"TPAE.all.gubbins-filtered.SNPs.vcf")

# ML tree calculated from WGS SNPs
Ampliseq_design.ML.tree.file <- paste0(Data_input_directory,"TPAE.all.gubbins-filtered.SNPs.iqtree.tre")

# SNP-scaled tree ancestrally reconstructed using pyjar.
TPAE.pyjar.tree.file <- paste0(Data_input_directory,"TPAE.all.gubbins-filtered.SNPs.aln.pyjar.joint.tre")

#############################################
#
#############################################
# Metadata for analyses

# Master Metadata spreadsheet
TPA.meta1.file <- paste0(Data_input_directory,"SuppTable1__TPAE_design_dataset_metadata.xlsx") 
TPA.meta1 <- readxl::read_excel(TPA.meta1.file)

#############################################
#
#############################################
# New Phylogenetic cluster assignments precalculated using rPinecone
TPAE.pinecone.10.file <- paste0(Data_input_directory,"TPAE.all.gubbins-filtered.SNPs.aln.pyjar.joint.tre.rPinecone.10.3__20220225.csv")


#############################################
# Precalculated FST scores for all newly redefined sublineages
FST.sublin.combined.TPAE.file <- paste0(Data_input_directory,"FST.sublin.combined.TPAE_20220606.csv")

#############################################
# PrimalScheme design files (outputs of primalscheme)
primalscheme.design.file <- paste0(Data_input_directory,"TPAE_discriminatory_PrimalScheme.primer.tsv")

SS14.primer_binding.locations.file <- paste0(Data_input_directory,"TP.disc.primalscheme.primerset.684_20220613.primer-location-hits-SS14.tsv")

primalscheme.design.bed.file <- paste0(Data_input_directory,"TP.disc.primalscheme.primerset.684.bed") 

#############################################
# In silico validation files
in_silico_pcr.results.file <- paste0(Data_input_directory,"in_silico_pcr.amplicon.recovery_list.tsv")

# primer blast search results
primer.search.output.all2.file <- paste0(Data_input_directory,"TP.disc.primalscheme.primerset.684__primerBLAST_20220616.tsv")

# primer blast search results - species-hits
primer.blast.species.hits.precalc.file <- paste0(Data_input_directory,"TP.disc.primalscheme.primerset.684__primerBLAST_species-hits_20220620.tsv")

#############################################
# 23S primer design files
TPA.refseq.file <- paste0(Data_input_directory,"23S_Nichols_2-operons1.fa")

COBS661K_window.search.23S.file <- paste0(Data_input_directory,"23S_Nichols_2-operons1.71bp-windows.20220623.fa_1_COBS-661K_results_table.txt")

COBS661K.metadata.file <- paste0(Data_input_directory,"Blackwell2018__File2_taxid_lineage_661K.txt")

# Primalscheme 23S design
primalscheme.design.23S.file <- paste0(Data_input_directory,"23S_scheme_primalscheme.primer.tsv")

primer.blast.23s.output.all.file <- paste0(Data_input_directory,"23S_o1_Nich_variable-site-masking.20220624.primerblast.searches.tsv")


#############################################
# South Africa Validation - MinION QC data 
TP20230502SA.readLength.filt.file <- paste0(Data_input_directory,"SouthAfrica_TP_Discriminatory_SA1+2+3-all_read-lengths_filt.tsv")

TP20230502SA.readLength.unfilt.file <- paste0(Data_input_directory,"SouthAfrica_TP_Discriminatory_SA1+2+3-all_read-lengths_unfilt.tsv")

TP20230502SA.region.depth.file <- paste0(Data_input_directory,"TP_Discriminatory.SA1+SA2+SA3_filtered.depth_redo-2023-12-01.tsv")

TP_SA.lab.metadata.file <- paste0(Data_input_directory,"SuppTable3__SouthAfrica_ONT-vs-Illumina_metadata.xlsx")

SA.Ampliseq_vs_IlluminaWGS.vcf.file <- paste0(Data_input_directory,"TP_SA1+2+3_Minion_vs_Illumina.all.2023-12-01.restrict-regions_good-regions.vcf")

#############################################
# Post validation primer dataset
#primalscheme.designs.SS14.binding_sites_full.table.good <- read.csv("/Users/mb29/Treponema/Treponema_Discriminatory_Sites__MinION/Analysis/TPAE.reliable-amplicons.regions.2024-05-28.csv")
primalscheme.designs.SS14.binding_sites_full.table.good <- read.csv(paste0(Data_input_directory,"TPAE.reliable-amplicons.regions.2024-05-28.csv"))

# Final primer scheme after filtering
primalscheme.designs.SS14.binding_sites_full.table__subset.good_amplicons.file <- paste0(Data_input_directory,"TP-Discriminatory-primers-684__validated-good-primers_site_table.20231206.csv")

primalscheme.designs.SS14.binding_sites_full.table__subset.good_amplicons <- read.csv(file=primalscheme.designs.SS14.binding_sites_full.table__subset.good_amplicons.file)

#############################################
# Phylogenetic analysis of amplicon derived datasets
candidate.amplicon.SNP.seqs.141.iqtree.file <- paste0(Data_input_directory,"TPAE-selected-sites_n185sites.20220606.rehash.treefile")

revised_candidate.amplicon.SNP.seqs.alignment.tree.filename <- paste0(Data_input_directory,"TPAE-selected-sites_n174sites__revised_amplicons.608dataset.20240528.fas.rehashed.treefile")

# Predicted amplicon sequence SNP alignment for final scheme with 608 genome design dataset 
candidate.amplicon.SNP.seqs.alignment.fasta.filename <- paste0(Data_input_directory,"TPAE-selected-sites_n174sites__revised_amplicons.608dataset.20240528.fas")

#############################################
# Comparing different datasets against the WGS tree
# Bootstraps from WGS IQ-Tree analysis
Ampliseq_design.ML.tree.bootstraps.file <- paste0(Data_input_directory,"TPAE.all.gubbins-filtered.SNPs.aln.rehashed.boottrees")

# Combined data file containing intermediate results from TreeSpace Concordance comparison
Combined_treeConcordance.df2.file <- paste0(Data_input_directory,"Combined_treeConcordance_20240924.csv")

#############################################
# Validation of scheme in silico using UK syphilis genome dataset (Beale 2023, Lancet Microbe)
UK_Illumina_data.vcf.file <- paste0(Data_input_directory,"TPA-uber.remasked.2020-11-10.goodcov25.gubbins.UK-only.+ref.WGS.vcf")

# UK dataset - IQtree calculated from amplicon SNP data, then ancestral reconstruction performed using pyjar to create a SNP-scaled tree
UK_Illumina_data.__AmpliSeq_sim.pyjar_tree.filename <- paste0(Data_input_directory,"UK_Illumina_data.__AmpliSeq_sim.seqs_variants_42sites.20240503.fix.pyjar.joint.tre")

# Grapetree (MST) plot from UK syphilis study (Beale 2023) derived from WGS tree and snp-scaled
UK_Illumina_WGS_grapetree.file <- paste0(Data_input_directory,"TPA-UK-2022-02-03.sublineage-MSTree.Inkscaped.svg")

# Grapetree (MST) plot from UK syphilis study (Beale 2023) simulated from amplicon data (59-amplicon scheme)
UK_Illumina_data.__AmpliSeq_sim.pyjar.grapetree.file <- paste0(Data_input_directory,"UK_Illumina_data.__AmpliSeq_sim.seqs_variants_42sites.20240503.fix.pyjar__grapetree.inkscaped.svg")

#############################################
# Zimbabwe field validation data
Zim.amplicon.metadata.file <- paste0(Data_input_directory,"SuppTable4__Zim_AmpliSeq_results.xlsx")

# Directory containing Zimbabwe coverage files
Zim.covdata.dir <- paste0(Data_input_directory,"Zim_coverage_summary/")


#############################################
# Simulating mutations in the genome to evaluate detection of novelty
sim.WGS.mutant.folder <- paste0(Data_input_directory,"simulated_mutations_250-sims/")

# Precalculated counts for all simulations and mutation frequencies
paste0(sim.WGS.mutant.folder, "SS14.mutate_sim.amplicon_site_counts__collated.csv")


```

\
NCBI API key: redacted for GitHub - users will need to add their own key here to reproduce the primerblast step from scratch. (Note that the results files are included in the dataset).
```{r}
my.ncbi.api.key.id <- "XXXX"
```
\
## Initial analysis of underlying dataset
\
Bring in ML tree of working dataset
```{r}
Ampliseq_design.ML.tree <- midpoint.root(read.tree(Ampliseq_design.ML.tree.file))

# remove duplicate version of reference genome
Ampliseq_design.ML.tree <- ape::drop.tip(Ampliseq_design.ML.tree, c("NC_021508_1_1","NC_021508.1_1"))

Ampliseq_design.ML.tree.gg <- ggtree(Ampliseq_design.ML.tree, size=0.35)
Ampliseq_design.ML.tree.gg
```

\
```{r}
# define colours for TPA sublineages  (from Beale et al, 2021)
sublineages.cols.brew <- data.frame(sublineage=factor(c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", NA, "Singleton"), levels=c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", NA, "Singleton")), sublineage.cols=c("#FC9272", "#EF3B2C", "#BAE4B3", "#74C476", "#238B45", "#FED98E", "#FE9929", "#C6DBEF", "#9ECAE1", "#6BAED6", "#3182BD", "#08519C", "#DADAEB", "#BCBDDC", "#9E9AC8", "#756BB1", "#54278F", "grey80", "grey80"), stringsAsFactors = F)
sublineages.cols.brew$sublineage.rename <- paste0("sublin-",sublineages.cols.brew$sublineage)
```

\
Make some datasets for trees
```{r}
TPA.meta1.ampliseq.filt <- TPA.meta1 %>% filter(Cleaned_fastq_id %in% Ampliseq_design.ML.tree$tip.label)


d.TPA.ampliseq.Subspecies <- TPA.meta1.ampliseq.filt %>% 
  select(Cleaned_fastq_id, Species) %>% 
  column_to_rownames("Cleaned_fastq_id")

TP.species.cols <- data.frame(Subspecies=c("TPA", "TPE", "TEN"), Subspecies.col=c("#e41a1c", "#377eb8", "#4daf4a") )


d.TPA.ampliseq.TPA_Lineage <- TPA.meta1.ampliseq.filt %>% 
  select(Cleaned_fastq_id, TPA_Lineage) %>% 
  mutate(TPA_Lineage = ifelse(TPA_Lineage=="SS14","SS14", ifelse(TPA_Lineage=="Nichols","Nichols",NA))) %>%
  column_to_rownames("Cleaned_fastq_id")

# TPA Lineage cols
TPA_Lineage.cols <- data.frame(Lineage=c("Nichols","SS14"), Lineage.col=c("royalblue2", "indianred1"))

```


\
Make some tree plots of this
```{r}
Ampliseq_design.ML.tree.heatmap.interval <- max(Ampliseq_design.ML.tree.gg$data$x)/15
Ampliseq_design.ML.tree.taxacount <- length(Ampliseq_design.ML.tree$tip.label)


# Add subspecies strip
p.Ampliseq_design.ML.tree.gg.meta1 <- gheatmap(Ampliseq_design.ML.tree.gg, d.TPA.ampliseq.Subspecies, color=NULL,width=0.05,offset=(0*Ampliseq_design.ML.tree.heatmap.interval), colnames_angle=45,colnames_offset_y=0.02, hjust=1,font.size=text.size.within-0.5) + 
  scale_fill_manual(values=TP.species.cols$Subspecies.col, breaks=TP.species.cols$Subspecies, name="Subspecies", guide = guide_legend(order = 1,ncol=2)) +
  theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  new_scale_fill() +
  coord_cartesian(y=c(-1-(Ampliseq_design.ML.tree.taxacount/20),Ampliseq_design.ML.tree.taxacount+1))

# Add TPA Lineage Strip
p.Ampliseq_design.ML.tree.gg.meta1 <- gheatmap(p.Ampliseq_design.ML.tree.gg.meta1, d.TPA.ampliseq.TPA_Lineage, color=NULL,width=0.05,offset=(1*Ampliseq_design.ML.tree.heatmap.interval), colnames_angle=45,colnames_offset_y=0.02, hjust=1,font.size=text.size.within-0.5) +
  scale_fill_manual(breaks=TPA_Lineage.cols$Lineage, values=TPA_Lineage.cols$Lineage.col, name="TPA\nLineage",na.value = "grey95", guide = guide_legend(order = 2,ncol=2)) +
  theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  new_scale_fill() +
  coord_cartesian(ylim=c(-70, length(Ampliseq_design.ML.tree$tip.label)))


p.Ampliseq_design.ML.tree.gg.meta1
```

\
Use pegas to read in WGS aln
```{r}
TPAE.SNPsVCF <- read.vcfR(TPAE.SNPsVCF.file, verbose = FALSE)
TPAE.SNPsVCF.fix <- getFIX(TPAE.SNPsVCF)
TPAE.SNPsVCF.fix <- data.frame(TPAE.SNPsVCF.fix[,c(2,4,5)], stringsAsFactors = F)
TPAE.SNPsVCF.fix$Key <- 1:nrow(TPAE.SNPsVCF.fix)

TPAE.SNPsVCF.gt <- extract_gt_tidy(TPAE.SNPsVCF)

TPAE.SNPsVCF.gt.f <- plyr::join(TPAE.SNPsVCF.gt, TPAE.SNPsVCF.fix[,c("Key","POS")], by="Key", type="left")
TPAE.SNPsVCF.gt.f$POS <- as.numeric(TPAE.SNPsVCF.gt.f$POS)
TPAE.SNPsVCF.gt.f$gt_GT <- as.numeric(TPAE.SNPsVCF.gt.f$gt_GT)

```
\
Numeric alleles don't explicitly label things as 'N'. Can we sort that out for plotting and calculation purposes?
```{r}
# Allele presence/absence (numeric)
TPAE.SNPsVCF.gt.f.spread <- tidyr::spread(TPAE.SNPsVCF.gt.f[,c("POS","Indiv","gt_GT")], POS, gt_GT) 
# Allele nucleotide identity (character)
TPAE.SNPsVCF.gtallele.f.spread <- tidyr::spread(TPAE.SNPsVCF.gt.f[,c("POS","Indiv","gt_GT_alleles")], POS, gt_GT_alleles) 
TPAE.SNPsVCF.gtallele.f.spread[TPAE.SNPsVCF.gtallele.f.spread=="*"] <- "N"


TPAE.SNPsVCF.gt.f <- TPAE.SNPsVCF.gt.f %>%
  mutate(gt_GT_Nfix = ifelse(gt_GT_alleles=="*","N", gt_GT))

TPAE.SNPsVCF.gt_GT_Nfix.f.spread <- tidyr::spread(TPAE.SNPsVCF.gt.f[,c("POS","Indiv","gt_GT_Nfix")], POS, gt_GT_Nfix) 
TPAE.SNPsVCF.gt_GT_Nfix.f.spread
```



\
# Evaluate discrimination of FST for example populations
```{r}
# exclude SS14 reference genome (in twice)
TPAE.SNPsVCF.gt.f.spread <- TPAE.SNPsVCF.gt.f.spread[TPAE.SNPsVCF.gt.f.spread$Indiv!="NC_021508_1_1",]

# exclude TEN genomes (only 2 available, so not informative to analysis)
TPAE.SNPsVCF.gt.f.spread <- TPAE.SNPsVCF.gt.f.spread[TPAE.SNPsVCF.gt.f.spread$Indiv %notin% c("15169_6#53.Treponema.ds2352679-reads","NZ_CP007548.1"),]

# Define species populations for dataset (binary classifications)
species.meta <- plyr::join(data.frame(Cleaned_fastq_id=TPAE.SNPsVCF.gt.f.spread$Indiv, stringsAsFactors = F),TPA.meta1[,c("Cleaned_fastq_id","Species")], by="Cleaned_fastq_id", type="left")

species.meta$pop <- ifelse(species.meta$Species=="TPA", 0, 1)

species.meta$TPA <- ifelse(species.meta$Species=="TPA", 0, 1)
species.meta$TPE <- ifelse(species.meta$Species=="TPA", 1, 0)

TPAE.SNPsVCF.gt.f.spread.Species_pop <- cbind(species.meta$pop, TPAE.SNPsVCF.gt.f.spread)


# Calculate Weir and Cockerham's FST, and extract the per-locus scores
wc.species <- wc(TPAE.SNPsVCF.gt.f.spread.Species_pop[,c(1,3:ncol(TPAE.SNPsVCF.gt.f.spread.Species_pop))],diploid=F)
wc.species.o <- data.frame(POS=as.numeric(gsub("X","",row.names(wc.species$per.loc))), FST=wc.species$per.loc$FST, stringsAsFactors = F)

# Define an example cuttoff and pull out significant hits
FST.cuttoff <- 0.99
wc.species.o$sig <- ifelse(wc.species.o$FST>FST.cuttoff, "sig","other")
wc.species.o[!is.na(wc.species.o$POS),]

wc.subspecies.disc.sighits <- wc.species.o[wc.species.o$sig=="sig",]
wc.subspecies.disc.sighits <- wc.subspecies.disc.sighits[!is.na(wc.subspecies.disc.sighits$POS),]


max(wc.species.o$FST, na.rm=T)

# Plot example hits
ggplot(wc.species.o, aes(POS, FST, color=sig)) + 
  geom_point(alpha=0.25) + 
  theme_bw() +
  theme(legend.position = 'bottom') +
  scale_color_manual(values=c("Red","Black"),  breaks=c("sig","other")) +
  labs(y=expression(F[ST]), x="Genome Position", color=expression(paste("Significant ", F[ST]))) +
  labs(title="Allelic sites discriminating T. pallidum subspecies pallidum and pertenue")

```

\
Look at top sites in phylogenetic context
```{r, fig.height=6, fig.width=6}
wc.species.o.top <- wc.species.o[(wc.species.o$FST>0.99 & !is.na(wc.species.o$FST)),]

wc.species.o.top.alleles <- TPAE.SNPsVCF.gt_GT_Nfix.f.spread[,c("Indiv", wc.species.o.top$POS)]


wc.species.o.top.alleles.chr <- wc.species.o.top.alleles %>%
  mutate(across(everything(), as.character)) %>%
  remove_rownames() %>%
  column_to_rownames("Indiv")



p.Ampliseq_design.ML.tree.gg.meta1_TPE.TPA.snps1 <- gheatmap(p.Ampliseq_design.ML.tree.gg.meta1, wc.species.o.top.alleles.chr, color=NULL,width=2,offset=(2.5*Ampliseq_design.ML.tree.heatmap.interval), colnames_angle=45,colnames_offset_y=0.02, hjust=1,font.size=text.size.within-0.5) +
  #scale_fill_manual(breaks=c("0","1","2","3"), values=c("grey80", "red2","blue2","green4"), name="Allele", na.value = "grey95", guide = guide_legend(order = 3,ncol=3)) +
  scale_fill_manual(breaks=c("0","1","2","3","N"), values=c("grey70", "red2","blue2","green4","grey95"), name="Allele", na.value = "grey95", guide = guide_legend(order = 3,ncol=3)) +
  theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  new_scale_fill()
p.Ampliseq_design.ML.tree.gg.meta1_TPE.TPA.snps1


```

## Calculating FST (function)
Wrap this up in a function to do FST - key script for calculating FST in each dataset
```{r}

calculate_fst_for_pop <- function(poplabel,my.locus.df, mypop.data, FST.cuttoff){
  
  # Extract relevant columns into separate dataframes
   # Dataframe containing multiallelic codes as integers
  my.locus.df.gt.f.spread.temp <- tidyr::spread(my.locus.df[,c("POS","Indiv","gt_GT")], POS, gt_GT) 
  # Second dataframe that uses character vectors, so 'N' is described for plotting
  my.locus.df.gt_GT_Nfix.f.spread.temp <- tidyr::spread(my.locus.df[,c("POS","Indiv","gt_GT_Nfix")], POS, gt_GT_Nfix)
  
  fst.join.meta <- plyr::join(data.frame(Cleaned_fastq_id=my.locus.df.gt.f.spread.temp$Indiv, stringsAsFactors = F),mypop.data, by="Cleaned_fastq_id", type="left")
  
  # do a cleanup of samples missing allele info - may be over cautious/error prone - keep an eye on this one
  #fst.join.meta[is.na(fst.join.meta[,2]),2] <- 1 #took this out after evaluation and because it's useful to retain allelic info.
  
  # combine allele information with population definitions
  fst.join.pops <- cbind(fst.join.meta[,2], my.locus.df.gt.f.spread.temp)
  # calculate site by site fst for pops using Weir and Cockrham estimates of Fstatistics (hierfstat package)
  fst.run <- wc(fst.join.pops[,c(1,3:ncol(fst.join.pops))],diploid=F)
  # fst.out contains the fst values for each site evaluated (and specifies whether they meet the defined cuttoff)
  fst.out <- data.frame(POS=as.numeric(gsub("X","",row.names(fst.run$per.loc))), FST=fst.run$per.loc$FST, stringsAsFactors = F)
  fst.out$population <- poplabel
  fst.out$sig <- ifelse(fst.out$FST>FST.cuttoff, "sig","other")
  # fst.alleles retrieves the allele information for those sites in each sample to allow plotting, etc
  fst.alleles <- my.locus.df.gt_GT_Nfix.f.spread.temp[,c("Indiv", fst.out[(fst.out$sig=="sig" & !is.na(fst.out$sig)),"POS"])]
  fst.out.list <- list(fst.out,fst.alleles)
  # fst values: fst.out.list[[1]]
  # significant alleles: fst.out.list[[2]]
  return(fst.out.list)
}

###
# Usage Example: 
#FST.species.TPA <- calculate_fst_for_pop("TPA",TPAE.SNPsVCF.gt.f, species.meta[,c(1,3)], 0.99)


################################################################################################

# Process SNPs for plotting against tree
prep.FST.for.plotting <- function(FSTout){
  FSTout.chr <- FSTout %>%
    mutate(across(everything(), as.character)) %>%
    remove_rownames() %>%
    column_to_rownames("Indiv")
  return(FSTout.chr)
}

################################################################################################

# And also make a function to examine the SNPs against the tree
plot_snps_against_tree <- function(basetree.plot, snps.df, widthscale, offset_num, Title, show_pos_headers=TRUE){
  
  keep.pos.info <- ifelse(show_pos_headers==TRUE, TRUE, FALSE)
  
  p.Ampliseq_design.ML.tree.gg.meta1__test_SNPs <- gheatmap(basetree.plot, snps.df, color=NULL,width=widthscale,offset=(offset_num*Ampliseq_design.ML.tree.heatmap.interval), colnames_angle=45,colnames_offset_y=0.02, hjust=1,font.size=text.size.within-0.5, colnames = keep.pos.info) +
    scale_fill_manual(breaks=c("0","1","2","3","4","N"), values=c("grey75", "red2","blue2","green4","yellow2","grey95"), name="Allele", na.value = "grey98", guide = guide_legend(order = 3,ncol=3)) +
    theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
    new_scale_fill() +
    labs(title=Title)
  return(p.Ampliseq_design.ML.tree.gg.meta1__test_SNPs) 
}
################################################################################################

```

\
Make example plots
```{r, fig.height=8, fig.width=8}
# without SNP labels
plot_snps_against_tree(p.Ampliseq_design.ML.tree.gg.meta1, wc.species.o.top.alleles.chr, 2,2.5, "Subspecies")
# with SNP labels
plot_snps_against_tree(p.Ampliseq_design.ML.tree.gg.meta1, wc.species.o.top.alleles.chr, 2,2.5, "Subspecies", show_pos_headers = F)
```

\
\
```{r}
gheatmap(Ampliseq_design.ML.tree.gg, d.TPA.ampliseq.Subspecies, color=NULL,width=0.05,offset=(0*Ampliseq_design.ML.tree.heatmap.interval), colnames_angle=45,colnames_offset_y=0.02, hjust=1,font.size=text.size.within-0.5, colnames = F) + 
  scale_fill_manual(values=TP.species.cols$Subspecies.col, breaks=TP.species.cols$Subspecies, name="Subspecies", guide = guide_legend(order = 1,ncol=2)) +
  theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  new_scale_fill() +
  coord_cartesian(y=c(-1-(Ampliseq_design.ML.tree.taxacount/20),Ampliseq_design.ML.tree.taxacount+1))
```


\
What about for SS14/Nichols?
```{r}
TPA.Lineages <- TPA.meta1[,c("Sample_Name","Cleaned_fastq_id","TPA_Lineage")]
TPA.Lineages$SS14 <- ifelse(TPA.Lineages$TPA_Lineage=="SS14", 0, 1)
TPA.Lineages$Nichols <- ifelse(TPA.Lineages$TPA_Lineage=="Nichols", 0, 1)

FST.species.TPA <- calculate_fst_for_pop("TPA",TPAE.SNPsVCF.gt.f, species.meta[,c(1,3)], 0.99)

FST.SS14 <- calculate_fst_for_pop("SS14",TPAE.SNPsVCF.gt.f,TPA.Lineages[,c("Cleaned_fastq_id","SS14")],0.95)
FST.Nichols <- calculate_fst_for_pop("Nichols",TPAE.SNPsVCF.gt.f,TPA.Lineages[,c("Cleaned_fastq_id","Nichols")],0.95)


plot_snps_against_tree(p.Ampliseq_design.ML.tree.gg.meta1, prep.FST.for.plotting(FST.SS14[[2]]), 2,2, "SS14")
plot_snps_against_tree(p.Ampliseq_design.ML.tree.gg.meta1, prep.FST.for.plotting(FST.Nichols[[2]]), 1,1.75, "Nichols")

```


Make another function to plot FST values along the genome 
```{r}
############################################
plot_fst_values <- function(fst.values) {
  sig.hit.count <- nrow(fst.values[(fst.values$sig=="sig" & !is.na(fst.values$sig)),])
  fst.plot <- ggplot(fst.values, aes(POS, FST, color=sig)) + 
    geom_point(alpha=0.25) + 
    theme_light() +
    scale_color_manual(values=c("Red","Black"),  breaks=c("sig","other")) +
    labs(y=expression(F[ST]), x="Genome Position", color=expression(paste("Significant ", F[ST])))
    ggtitle(paste0(sig.hit.count," discriminating sites for ",fst.values$population[1]))
  return(fst.plot)
}
############################################


plot_fst_values(FST.species.TPA[[1]])

plot_fst_values(FST.SS14[[1]])
plot_fst_values(FST.Nichols[[1]])
```

\
OK, let's make an exemplar figure that demonstrates the process
```{r, fig.height=7, fig.width=7}
FST.Nichols <- calculate_fst_for_pop("Nichols",TPAE.SNPsVCF.gt.f,TPA.Lineages[,c("Cleaned_fastq_id","Nichols")],0.90)

p.Fst.disc_sites.vs.tree_Nichols <- plot_snps_against_tree(p.Ampliseq_design.ML.tree.gg.meta1, prep.FST.for.plotting(FST.Nichols[[2]]), 2,1.75, "SS14") + coord_cartesian(ylim=c(-1-(Ampliseq_design.ML.tree.taxacount/8), Ampliseq_design.ML.tree.taxacount+1))

p.Fst.disc_sites_scatter_Nichols <- plot_fst_values(FST.Nichols[[1]])  

#plot_grid(p.Fst.disc_sites_scatter_Nichols + labs(title=paste("A - Site-by-site",expression(F[ST]),"discriminating Nichols Lineage")), p.Fst.disc_sites.vs.tree_Nichols + labs(title="B - Discriminatory SNPs across the phylogeny"), ncol=1, rel_heights = c(1,2))


p.FST_Nichols_sites.scatter_and_tree.combi <- plot_grid(p.Fst.disc_sites_scatter_Nichols + labs(title=expression(paste("A - Site-by-site ", F[ST] ," discriminating Nichols Lineage"))), p.Fst.disc_sites.vs.tree_Nichols + labs(title="B - Discriminatory SNPs across the phylogeny"), ncol=1, rel_heights = c(1,2))

p.FST_Nichols_sites.scatter_and_tree.combi


#ggsave(plot=p.FST_Nichols_sites.scatter_and_tree.combi, paste0(Figures_directory,"SuppFig2__Nichols-sites.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=220, height=180, device='pdf', dpi=800) 

```


# New sublineage classifications

We have previously defined sublineages for TPA in Beale et al, 2021 (Nat Micro). However, this was only for TPA - did not include subspecies pertenue (TPE) or subspecies endemicum (TEN). 

Ok, lets do a new sublineage classification that accounts for TPE (only 2 TEN genomes in dataset anyway)
```{r}
# read in pyjar tree
TPAE.pyjar.tree <- midpoint.root(read.tree(TPAE.pyjar.tree.file))

# run rPinecone
#TPAE.pinecone.output <- rPinecone::pinecone(TPAE.pyjar.tree,10,3) # standard approach used for TPA
# output to dataframe, and create a merged singleton variable
#TPAE.pinecone.output.1 <- data.frame(TPAE.pinecone.output$table,stringsAsFactors = T)
#TPAE.pinecone.output.1$Sub.lineage.sing <- gsub("Singleton\\_.+","Singleton",TPAE.pinecone.output.1$Sub.lineage,perl=T)

# merge with additional metadata (sample name, TPA-pinecone assignment from 2021 NM paper)
#TPAE.pinecone.output.1 <- left_join(TPAE.pinecone.output.1, data.frame(Taxa=TPA.meta.globalpaper$Cleaned_fastq_id, TPA.pinecone.sublineage=TPA.meta.globalpaper$TPA.pinecone.sublineage, stringsAsFactors=F), by="Taxa")

#TPAE.pinecone.output.1 <- left_join(TPAE.pinecone.output.1, data.frame(Taxa=TPA.meta1$Cleaned_fastq_id, Sample_Name=TPA.meta1$Sample_Name, stringsAsFactors=F), by="Taxa")


# This takes a long time to run - write out to file
#write.csv(TPAE.pinecone.output.1, file=paste0(TPAE.pyjar.tree.file, ".rPinecone.10.3__",format(Sys.Date(),"%Y%m%d"),".csv"), row.names = F)

```
\

```{r}
# Read in precalculated rPinecone clusters
TPAE.pinecone.10 <- read.table(TPAE.pinecone.10.file, check.names = F, comment.char = "", row.names = NULL, header = T, sep=",")
```
\
\
Look at assignments, and create scheme for TPE
```{r}
TPAE.pinecone.10 <- TPAE.pinecone.10 %>% select(Taxa, Sub.lineage, Sub.lineage.sing, Major.Sub.lineage, TPA.pinecone.sublineage, Sample_Name)
TPAE.pinecone.10 <- TPAE.pinecone.10[TPAE.pinecone.10$Taxa!="NC_021508_1_1",]

TPAE.pinecone.10.tpe.only <- TPAE.pinecone.10[TPAE.pinecone.10$Major.Sub.lineage==3,]

TPE.sublins <- data.frame(Sub.lineage.sing=sort(unique(TPAE.pinecone.10.tpe.only$Sub.lineage.sing)), stringsAsFactors=F)
TPE.sublins$TPE.pinecones <- paste0("TPE", seq(20,20+(length(TPE.sublins$Sub.lineage.sing)-1)))

TPAE.pinecone.10 <- left_join(TPAE.pinecone.10, TPE.sublins, by="Sub.lineage.sing") 
TPAE.pinecone.10 <-  TPAE.pinecone.10 %>% dplyr::arrange(as.numeric(TPA.pinecone.sublineage), TPE.pinecones)


TPAE.pinecone.10$TPA.TPE.scheme <- ifelse(!is.na(TPAE.pinecone.10$TPA.pinecone.sublineage),TPAE.pinecone.10$TPA.pinecone.sublineage, TPAE.pinecone.10$TPE.pinecones)


TPA.TPE.scheme.list <- unique(TPAE.pinecone.10$TPA.TPE.scheme)
TPA.TPE.scheme.list <- TPA.TPE.scheme.list[TPA.TPE.scheme.list!="Singleton"]
TPA.TPE.scheme.list <- TPA.TPE.scheme.list[!is.na(TPA.TPE.scheme.list)]

# These classifications are now incorporated into the main metadata table for the study
```
\
How many singletons?
```{r}
TPAE.pinecone.10 %>%
  filter(grepl("singleton",Sub.lineage.sing)) %>% nrow()
```
\
Make a colour scheme for each sublineage
```{r}
TPA.TPE.scheme.cols <- data.frame(TPA.TPE.sublineage = c(TPA.TPE.scheme.list,"Singleton"))

#N40 <- createPalette(length(TPA.TPE.scheme.cols$TPA.TPE.sublineage),  c("#ff0000", "#00ff00", "#0000ff"))

TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols <- c("#FF2A00", "#1CFE1C", "#2A16FB", "#FBD1D4", "#FF22E3", "#1CD1FF", "#FCE400", "#00631C", "#950038", "#6D2E87", "#FC9100", "#0DFBD7", "#8B5A00", "#B0EF7E", "#CA0DFF", "#FF0D82", "#FD87CE", "#266877", "#949AFF", "#C7CEFA", "#BFEBCD", "#E98CFE", "#864562", "#DCCC84", "#FB6258", "#FF9D96", "#00F693", "#7E7D66", "#EC0DA3", "#7D0DC1", "#004F9A", "#62C8CC", "#E1A722", "#AA1699", "#D094D1", "#53C07E", "#728900", "#FB6296", "#A1F600", "#B7530D","grey90")

```
\
Plot new sublineages with tree
```{r, fig.width=6, fig.height=6}
d.TPAE.pinecone.10.TPAE.sublineages <- data.frame(row.names=TPAE.pinecone.10$Taxa, TPAE.sublineage=TPAE.pinecone.10$TPA.TPE.scheme, stringsAsFactors=F)

# Add new TPA/TPE Lineage Strip to tree
p.Ampliseq_design.ML.tree.gg.meta1.TPA.TPE.sublins <- gheatmap(p.Ampliseq_design.ML.tree.gg.meta1, d.TPAE.pinecone.10.TPAE.sublineages, color=NULL,width=0.05,offset=(2*Ampliseq_design.ML.tree.heatmap.interval), colnames_angle=45,colnames_offset_y=0.02, hjust=1,font.size=text.size.within-0.5) +
  scale_fill_manual(breaks=TPA.TPE.scheme.cols$TPA.TPE.sublineage, values=TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols, name="Sublineage", na.value = "grey95", guide = guide_legend(order = 3,ncol=3)) +
  theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  new_scale_fill() +
  coord_cartesian(ylim=c(-1-(Ampliseq_design.ML.tree.taxacount/10), Ampliseq_design.ML.tree.taxacount+1))
p.Ampliseq_design.ML.tree.gg.meta1.TPA.TPE.sublins

```


\
Make some summary plots about this
```{r}
#TPA.meta1.ampliseq.filt.sublin <- TPA.meta1.ampliseq.filt %>% left_join((TPAE.pinecone.10 %>% select(Taxa,Sample_Name, TPA.TPE.scheme)), by=c("Cleaned_fastq_id"="Taxa", "Sample_Name") )

TPA.meta1.ampliseq.filt.sublin <- TPA.meta1


TPA.meta1.ampliseq.filt.sublin %>% 
  group_by(Species) %>% 
  summarise(Count=n()) %>%
  mutate(Species = factor(Species, levels=c("TPA","TPE","TEN"))) %>%
  ggplot(aes(y=Species, x=Count, fill=Species)) +
  geom_barh(stat='identity', width=0.65) + 
  theme_bw() + theme.text.size + legend.size +
  x.theme.axis.rotate.angle +
  labs(x="Sample Count", y="Subspecies") + scale_x_continuous(breaks=pretty) +
  scale_fill_manual(values=TP.species.cols$Subspecies.col, breaks=TP.species.cols$Subspecies, name="Subspecies", guide = guide_legend(order = 1,ncol=2))

TPA.meta1.ampliseq.filt.sublin %>%
  group_by(TPA.TPE.scheme) %>%
  summarise(Count=n()) %>%
  mutate(TPA.TPE.scheme = factor(TPA.TPE.scheme, levels=TPA.TPE.scheme.cols$TPA.TPE.sublineage)) %>%
  ggplot(aes(y=TPA.TPE.scheme, x=Count, fill=TPA.TPE.scheme)) +
  geom_barh(stat='identity', width=0.65) + 
  theme_bw() + theme.text.size + legend.size +
  x.theme.axis.rotate.angle +
  scale_fill_manual(breaks=TPA.TPE.scheme.cols$TPA.TPE.sublineage, values=TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols, name="Sublineage") +
  labs(y="Sublineage", x="Sample Count")
  
TPA.meta1.ampliseq.filt.sublin %>%
  group_by(Geo_Country) %>%
  summarise(Count=n()) %>%
  #mutate(TPA.TPE.scheme = factor(TPA.TPE.scheme, levels=TPA.TPE.scheme.cols$TPA.TPE.sublineage)) %>%
  ggplot(aes(y=Geo_Country, x=Count, fill=Geo_Country)) +
  geom_barh(stat='identity', width=0.65) + 
  theme_bw() + theme.text.size + legend.size +
  x.theme.axis.rotate.angle +
  scale_fill_manual(breaks=TPA.TPE.scheme.cols$TPA.TPE.sublineage, values=TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols, name="Sublineage") +
  labs(y="Sublineage", x="Sample Count")  

```

\
```{r}
p.TPA.meta1.ampliseq.Species_treemap <- TPA.meta1.ampliseq.filt.sublin %>% 
  group_by(Species) %>% 
  summarise(Count=n()) %>%
  mutate(Species = factor(Species, levels=c("TPA","TPE","TEN"))) %>%
  ggplot(aes(area=Count, fill=Species, label= paste(Species, "\n(", Count,")", sep = ""))) +
  geom_treemap(color='transparent') +
  geom_treemap_text(colour = "white", place = "centre", size = standard.textsize-3) +
  scale_fill_manual(values=TP.species.cols$Subspecies.col, breaks=TP.species.cols$Subspecies, name="Subspecies", guide = guide_legend(order = 1,ncol=1)) +
  theme_bw() + theme.text.size + legend.size + 
  #theme(legend.position='top') +
  labs(title='B - Subspecies distributions') +
  NULL
p.TPA.meta1.ampliseq.Species_treemap


p.TPA.meta1.ampliseq.Sublineage_treemap <- TPA.meta1.ampliseq.filt.sublin %>% 
  group_by(TPA.TPE.scheme) %>%
  summarise(Count=n()) %>%
  mutate(TPA.TPE.scheme = factor(TPA.TPE.scheme, levels=TPA.TPE.scheme.cols$TPA.TPE.sublineage)) %>%
  ggplot(aes(area=Count, fill=TPA.TPE.scheme, label= paste(TPA.TPE.scheme, " (", Count,")", sep = ""))) +
  geom_treemap(color='transparent') +
  geom_treemap_text(colour = "white", place = "centre", size = standard.textsize-3) +
  scale_fill_manual(breaks=TPA.TPE.scheme.cols$TPA.TPE.sublineage, values=TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols, name="Sublineage", guide = guide_legend(order = 2,ncol=3)) +
  theme_bw() + theme.text.size + legend.size + theme(legend.position='right') +
  labs(title='C - Sublineage distributions') +
  NULL
p.TPA.meta1.ampliseq.Sublineage_treemap


createPalette(length(unique(TPA.meta1.ampliseq.filt.sublin$Geo_Country)),  c("#ff0000", "#00ff00", "#0000ff"))


TPAE.Geo_country_cols <- data.frame(Geo_Country= sort(unique(TPA.meta1.ampliseq.filt.sublin$Geo_Country)),Geo_Country.col=c("#FF0016", "#0DFF0D", "#2226F8", "#FFCECC", "#FE00DD", "#16D6FE", "#E4E20D", "#26995F", "#FB8922", "#6E2E85", "#BF005F", "#CD0DFE", "#514732", "#F98AD4", "#D3CBFF", "#AF861C", "#226DC3", "#00FDE8", "#853222", "#1C6E82", "#A3F87C", "#C4EBDC", "#DD8AFE", "#D13216", "#DDE49C", "#00F9A9", "#86225F", "#FE92A4", "#7722C1", "#FE0D73", "#F900AC", "#657516", "#FDB400", "#A90D9C", "#9C899B", "#FFAD7E"))


p.TPA.meta1.ampliseq.Country_treemap <- TPA.meta1.ampliseq.filt.sublin %>% 
  group_by(Geo_Country) %>%
  summarise(Count=n()) %>%
  ggplot(aes(area=Count, fill=Geo_Country, label= paste(Geo_Country, " (", Count,")", sep = ""))) +
  geom_treemap(color='transparent') +
  geom_treemap_text(colour = "white", place = "centre", size = standard.textsize-3) +
  theme_bw() + theme.text.size + legend.size + theme(legend.position='right') +
  scale_fill_manual(values=TPAE.Geo_country_cols$Geo_Country.col, breaks=TPAE.Geo_country_cols$Geo_Country, name="Country", guide = guide_legend(order = 3, ncol=3)) +
  labs(title='D - Geographical distributions') +
  NULL
p.TPA.meta1.ampliseq.Country_treemap



p.TPA.meta1.ampliseq.Species.Sublineage_treemap.combi <- plot_grid(p.TPA.meta1.ampliseq.Species_treemap, p.TPA.meta1.ampliseq.Sublineage_treemap, ncol=2, rel_widths = c(2,3))

p.TPA.meta1.ampliseq.Country_treemap.combi_space <- plot_grid(p.TPA.meta1.ampliseq.Country_treemap, "", rel_widths = c(6,1) )

p.TPA.meta1.ampliseq.metadata_treemap_combi <- plot_grid(p.TPA.meta1.ampliseq.Species.Sublineage_treemap.combi, p.TPA.meta1.ampliseq.Country_treemap.combi_space, ncol=1)

p.TPA.meta1.ampliseq.metadata_treemap_combi
```
\
Make a combined figure plot?
```{r, fig.width=8, fig.height=10}
p.Ampliseq_design.ML.tree_with_Treemap_plots_combi <- plot_grid(p.Ampliseq_design.ML.tree.gg.meta1.TPA.TPE.sublins + labs(title='A - Whole Genome Phylogeny') + coord_cartesian(y=c(-60, Ampliseq_design.ML.tree.taxacount+1)), p.TPA.meta1.ampliseq.metadata_treemap_combi, ncol=1, scale=0.98, rel_heights = c(3,2))

p.Ampliseq_design.ML.tree_with_Treemap_plots_combi


#ggsave(plot=p.Ampliseq_design.ML.tree_with_Treemap_plots_combi, paste0(Figures_directory,"SuppFig1__Tree_+Treemaps.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=180, height=300, device='pdf', dpi=800)

```


\
Now evaluate each sublineage against the tree
\
First construct the population assignments for the different sublineages we want to differentiate
```{r}
# Create a population assignment for each sublineage
TPA.TPE.sublins <- TPAE.pinecone.10[,c("Sample_Name","Taxa","TPA.TPE.scheme")]
colnames(TPA.TPE.sublins)[2] <- "Cleaned_fastq_id"
#TPA.TPE.global.sublins.list <- sort((unique(TPA.TPE.sublins$TPA.TPE.scheme)))
TPA.TPE.global.sublins.list <- TPA.TPE.scheme.list

for (current in TPA.TPE.global.sublins.list){
  TPA.TPE.sublins$sublin.class <- ifelse(TPA.TPE.sublins$TPA.TPE.scheme==current,0,1)
  colnames(TPA.TPE.sublins)[ncol(TPA.TPE.sublins)] <- paste0("sublin-",current)
}
TPA.TPE.sublins

# Now add in SS14 and Nichols variables
TPA.TPE.sublins <- left_join(TPA.TPE.sublins, TPA.Lineages[,c("Cleaned_fastq_id","SS14")], by="Cleaned_fastq_id")
TPA.TPE.sublins <- left_join(TPA.TPE.sublins, TPA.Lineages[,c("Cleaned_fastq_id","Nichols")], by="Cleaned_fastq_id")

# And add in a subspecies delineator
TPA.TPE.sublins <- left_join(TPA.TPE.sublins, species.meta[,c("Cleaned_fastq_id","TPA", "TPE")], by="Cleaned_fastq_id")

TPA.TPE.sublins
```
\
So an example of the population input looks like this:
```{r}
TPA.TPE.sublins[,c("Cleaned_fastq_id",paste0("sublin-",1))]
```

\
Cleaned_fastq_id    sublin-1
<chr>   <dbl>
22931_6#11.Treponema.ds2500000-reads	0			
27455_2#29.Treponema.ds2500000-reads	0			
SRR3268732.Treponema.ds301291-reads	0			
27455_4#12.Treponema.ds2500000-reads	0			
27455_5#23.Treponema.ds2500000-reads	0	


\
\
# Now find discriminatory sites in a loop
\
```{r}
TPA.TPE.global.sublins.list.s <- c("TPE", "TPA", "Nichols","SS14", paste0("sublin-",TPA.TPE.global.sublins.list))

#FST.sublin.combined.TPAE <- NULL
#for (current in TPA.TPE.global.sublins.list.s[TPA.TPE.global.sublins.list!="Singleton"]){
#  #FST.sublin.sublin.current <- calculate_fst_for_pop(current,TPAE.SNPsVCF.gt.f, #TPA.TPE.sublins[,c("Cleaned_fastq_id",paste0("sublin-",current))],0.9)
#    FST.sublin.sublin.current <- calculate_fst_for_pop(current,TPAE.SNPsVCF.gt.f.spread, #TPA.TPE.sublins[,c("Cleaned_fastq_id",current)],0.9)
#  FST.sublin.combined.TPAE <- rbind(FST.sublin.combined.TPAE, FST.sublin.sublin.current[[1]])
#}
#FST.sublin.combined.TPAE <- FST.sublin.combined.TPAE[!is.na(FST.sublin.combined.TPAE$sig),]

#write.csv(FST.sublin.combined.TPAE, file="/Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/Gubbins_on-SS14-mapped/FST.sublin.combined.TPAE_20220606.csv", row.names = F)


# Read in precalculated FST scores
FST.sublin.combined.TPAE <- read.csv(FST.sublin.combined.TPAE.file)

FST.sublin.combined.TPAE.sig <- FST.sublin.combined.TPAE[(FST.sublin.combined.TPAE$sig=="sig"),]

FST.sublin.combined.TPAE.sig

length(unique(FST.sublin.combined.TPAE.sig$POS))

```
\
Make combined color scheme
```{r}
TP.FST_combined.cols <- data.frame(Classification = c(TP.species.cols$Subspecies, TPA_Lineage.cols$Lineage, TPA.TPE.scheme.cols$TPA.TPE.sublineage), 
Color = c(TP.species.cols$Subspecies.col, TPA_Lineage.cols$Lineage.col, TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols), stringsAsFactors = F) 

TP.FST_combined.cols <- TP.FST_combined.cols %>% 
  mutate(Population_sl = ifelse(Classification %in% c("TPA", "TPE", "TEN", "Nichols", "SS14"), Classification, paste0("sublin-",Classification)))
```

\
How many sites have we identified for each sublineage?
```{r, fig.height=6, fig.width=6}
disc.sites.per.sublineage <- FST.sublin.combined.TPAE.sig %>% 
  distinct(population, POS) %>%
  dplyr::group_by(population) %>%
  dplyr::summarise(count=n()) %>%
  dplyr::mutate(sublineage=(gsub("sublin-","",population))) %>%
  dplyr::arrange(sublineage) %>%
  dplyr::mutate(sublineage=factor(sublineage,levels=sort(sublineage))) %>%
  dplyr::mutate(level=ifelse(sublineage %in% c("Nichols","SS14"),"TPA_Lineage", ifelse(sublineage %in% c("TPA", "TPE"), "Subspecies", "TP_Sublineage")))
  
disc.sites.per.sublineage %>% 
  filter(level == "TP_Sublineage") %>%
  mutate(subspecies=ifelse(grepl("TPE",sublineage),"TPE","TPA")) %>%
  mutate(TPA.lineage=ifelse(population %in% paste0("sublin-",as.character(1:5)), "SS14", ifelse(population %in% paste0("sublin-",as.character(6:17)), "Nichols", "Other"))) %>%
  mutate(median.all=median(count), mean.all=mean(count), max.all=max(count), min.all=min(count)) %>%
  group_by(subspecies) %>%
  mutate(median.subspecies=median(count), mean.subspecies=mean(count), max.subspecies=max(count), min.subspecies=min(count)) %>% ungroup() %>%
  group_by(TPA.lineage) %>%
  mutate(median.lineage=median(count), mean.lineage=mean(count), max.lineage=max(count), min.lineage=min(count)) 
  

```
\
Make plot
```{r}
p.disc.sites.per.sublineage.barplot <- disc.sites.per.sublineage %>%
  filter(level!="Subspecies") %>% 
  mutate(sublineage=factor(sublineage, levels=TP.FST_combined.cols$Classification)) %>%
  mutate(levels=factor(level, levels=(c("Subspecies", "TPA_Lineage", "TP_Sublineage")))) %>%
  ggplot(aes(count, sublineage, fill=sublineage)) + 
  geom_barh(stat='identity', width=0.65) + 
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='top') +
  x.theme.axis.rotate.angle +
  labs(x="Site Count", y="Sublineage") + scale_x_continuous(breaks=pretty) +
  scale_fill_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Classification, name="Classification", na.value = 'grey95') + theme(legend.position = 'none') +
  facet_grid(level~., scales = 'free_y', space='free_y') + y.facet.text.rotate
p.disc.sites.per.sublineage.barplot
```

\
plot unique sites for all sublineages against tree

```{r, fig.width=15, fig.height=8}
FST.sublin.combined.sig.unique.sites <- sort(unique(FST.sublin.combined.TPAE.sig$POS))

#p.Ampliseq_design.ML.tree.gg.meta1.TPA.TPE.sublins__all.FST.disc.sites <- plot_snps_against_tree(p.Ampliseq_design.ML.tree.gg.meta1.TPA.TPE.sublins, prep.FST.for.plotting(TPAE.SNPsVCF.gt.f.spread), 2.5, 3.5, "All Sublineages")

# Extract sites that are discriminatory
TPAE.SNPsVCF.gt_GT_Nfix.f.spread__discrimnatory_all <- TPAE.SNPsVCF.gt_GT_Nfix.f.spread %>%
  select(Indiv,as.character(FST.sublin.combined.sig.unique.sites))

# Plot
p.Ampliseq_design.ML.tree.gg.meta1.TPA.TPE.sublins__all.FST.disc.sites <- plot_snps_against_tree(p.Ampliseq_design.ML.tree.gg.meta1.TPA.TPE.sublins, prep.FST.for.plotting(TPAE.SNPsVCF.gt_GT_Nfix.f.spread__discrimnatory_all), 2.5, 3.5, "All Sublineages", show_pos_headers = F)

# This is a complex plot - rasterise it to reduce the data size
p.Ampliseq_design.ML.tree.gg.meta1.TPA.TPE.sublins__all.FST.disc.sites <- rasterise(p.Ampliseq_design.ML.tree.gg.meta1.TPA.TPE.sublins__all.FST.disc.sites, dpi=400)

p.Ampliseq_design.ML.tree.gg.meta1.TPA.TPE.sublins__all.FST.disc.sites


#ggsave(plot=p.Ampliseq_design.ML.tree.gg.meta1.TPA.TPE.sublins__all.FST.disc.sites, paste0(Ancillary_Figures_directory,"All-DiscSites_TPAE-sublineages.vs.tree.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=240, height=180, device='pdf', dpi=400)

```

\
\
Plot positioning of sites
```{r, fig.width=10, fig.height=7}
#TPAE.SNPsVCF.gt_GT_Nfix.f.spread
#TPAE.SNPsVCF.gt_GT_Nfix.f.spread__discrimnatory_all

nrow(FST.sublin.combined.TPAE.sig %>% filter(population %notin% c("Nichols","SS14", "TPA", "TPE")) %>% distinct(POS))

p.FST.sublin.combined.TPAE.sig_all.sublins_point.plot <- FST.sublin.combined.TPAE.sig %>%
  mutate(population=factor(population, levels=(TP.FST_combined.cols$Population_sl[c(2,1,4:45)]))) %>%
  filter(population %notin% c("Nichols","SS14", "TPA", "TPE")) %>%
  arrange(POS) %>% distinct(POS, population, .keep_all = T) %>%
  ggplot(aes(x=POS, y=FST, color=population)) +
  geom_point(alpha=0.5, size=1) + 
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  x.theme.axis.rotate +
  labs(y=expression(F[ST]), x="Genome Position", color=expression(paste("Significant ", F[ST]))) +
  scale_color_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Sublineage", na.value = 'grey95', guide = guide_legend(ncol=1)) + 
  coord_cartesian(y=c(0.75,1) ) +
  labs(title=paste0(nrow(FST.sublin.combined.TPAE.sig %>% filter(population %notin% c("Nichols","SS14", "TPA", "TPE")) %>% distinct(POS)), " discriminating alleles across all 40 defined sublineages")) +
  facet_wrap(vars(population)) + theme(legend.position = 'none')
p.FST.sublin.combined.TPAE.sig_all.sublins_point.plot


#ggsave(plot=p.FST.sublin.combined.TPAE.sig_all.sublins_point.plot, paste0(Figures_directory,"SuppFig3__FST-all-sublins.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=220, height=180, device='pdf', dpi=400)

```

\

# Positional clustering of sites
Positional clustering of all sites
```{r, fig.height=8, fig.width=6}
p.FST.sublin.combined.TPAE.sig.pos.cluster_pop.specific <- 
  FST.sublin.combined.TPAE.sig %>%
  mutate(population=factor(population, levels=(TP.FST_combined.cols$Population_sl[c(2,1,4:45)]))) %>%
  filter(population %notin% c("Nichols","SS14", "TPA", "TPE")) %>%
  arrange(POS) %>% distinct(POS, population, .keep_all = T) %>%
  group_by(population) %>%
  mutate(rownum.pop = row_number()) %>%
  mutate(dist2next.pop = ifelse(rownum.pop==1,0, POS - lag(POS))) %>%
  ggplot(aes(y=population, x=dist2next.pop, color=population)) + 
  geom_quasirandom(size=0.5, alpha=0.5) +
  theme_bw() + theme.text.size + 
  scale_x_log10(breaks=c(1,100,10000,1000000)) +
  coord_cartesian(xlim=c(1,1000000)) +
  scale_color_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Sublineage", na.value = 'grey95') + theme(legend.position='none') +
  labs(y="Population Specific Sites", x="Distance between adjacent discriminatory SNPs (bp)") +
  geom_vline(xintercept=300, color='blue')
#p.FST.sublin.combined.TPAE.sig.pos.cluster_pop.specific

p.FST.sublin.combined.TPAE.sig.pos.cluster_all.pops <- FST.sublin.combined.TPAE.sig %>%
  mutate(population=factor(population, levels=(TP.FST_combined.cols$Population_sl[c(2,1,4:45)]))) %>%
  filter(population %notin% c("Nichols","SS14", "TPA", "TPE")) %>%
  arrange(POS) %>% distinct(POS, .keep_all = T) %>%
  #group_by(population) %>%
  mutate(rownum.pop = row_number()) %>%
  mutate(dist2next.pop = ifelse(rownum.pop==1,0, POS - lag(POS))) %>%
  ggplot(aes(y='All Sites', x=dist2next.pop, color=population)) + 
  geom_quasirandom(size=0.5, alpha=0.5) +
  theme_bw() + theme.text.size + 
  scale_x_log10(breaks=c(1,100,10000,1000000)) +
  coord_cartesian(xlim=c(1,1000000)) +
  scale_color_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Sublineage", na.value = 'grey95') + theme(legend.position='none') +
  labs(y="", x="Distance between adjacent discriminatory SNPs (bp)") + 
  geom_vline(xintercept=300, color='blue')
#p.FST.sublin.combined.TPAE.sig.pos.cluster_all.pops


p.FST.sublin.combined.TPAE.sig.pos.cluster_pop.combi <- plot_grid(p.FST.sublin.combined.TPAE.sig.pos.cluster_pop.specific + x.theme.strip, p.FST.sublin.combined.TPAE.sig.pos.cluster_all.pops, ncol=1, align="v", rel_heights = c(4,1))
p.FST.sublin.combined.TPAE.sig.pos.cluster_pop.combi

#ggsave(plot=p.FST.sublin.combined.TPAE.sig.pos.cluster_pop.combi, paste0(Figures_directory,"SuppFig5__SNP_adjacent_distances.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=160, height=180, device='pdf', dpi=400)
```
\
Get some stats on those numbers
```{r}
# median distance when considering pops separately
FST.sublin.combined.TPAE.sig %>%
  mutate(population=factor(population, levels=(TP.FST_combined.cols$Population_sl[c(2,1,4:45)]))) %>%
  filter(population %notin% c("Nichols","SS14", "TPA", "TPE")) %>%
  arrange(POS) %>% distinct(POS, population, .keep_all = T) %>%
  group_by(population) %>%
  mutate(rownum.pop = row_number()) %>%
  mutate(dist2next.pop = ifelse(rownum.pop==1,0, POS - lag(POS))) %>%
  mutate(mean_dist.pop=mean(dist2next.pop)) %>%
  ungroup() %>%
  summarise(mean_dist.allpops=mean(dist2next.pop), median_dist.allpops=median(dist2next.pop))

# Median distance when considered together as a population
FST.sublin.combined.TPAE.sig %>%
  mutate(population=factor(population, levels=(TP.FST_combined.cols$Population_sl[c(2,1,4:45)]))) %>%
  filter(population %notin% c("Nichols","SS14", "TPA", "TPE")) %>%
  arrange(POS) %>% distinct(POS, .keep_all = T) %>%
  #group_by(population) %>%
  mutate(rownum.pop = row_number()) %>%
  mutate(dist2next.pop = ifelse(rownum.pop==1,0, POS - lag(POS))) %>% mutate(mean_dist.pop=mean(dist2next.pop)) %>%
  ungroup() %>%
  summarise(mean_dist.allpops=mean(dist2next.pop), median_dist.allpops=median(dist2next.pop))
```



Can we infer genome positional clustering of sites?
```{r}
#FST.sublin.combined.sig
FST.sublin.combined.sig.unique.sites.roll <- data.frame(position=FST.sublin.combined.sig.unique.sites, sites=1, stringsAsFactors = F)

FST.sublin.combined.sig.unique.sites.roll <- plyr::join(data.frame(position=c(1:1138216), stringsAsFactors = F), FST.sublin.combined.sig.unique.sites.roll, by="position", type='left')

FST.sublin.combined.sig.unique.sites.roll[is.na(FST.sublin.combined.sig.unique.sites.roll$sites),"sites"] <- 0

windowsize <- 500


disc.sites.window <- data.frame(position=RcppRoll::roll_mean(FST.sublin.combined.sig.unique.sites.roll$position,windowsize, by=5),stringsAsFactors = F)

disc.sites.window$disc.sites <- RcppRoll::roll_sum(FST.sublin.combined.sig.unique.sites.roll$sites,windowsize, by=5)


ggplot(disc.sites.window, aes(position, disc.sites)) + 
  geom_point(alpha=0.25) + 
  theme_light() + theme.text.size +
  labs(y="Discriminatory sites in window", x="Genome position\n(500 bp windows)")

```
\

So there are a number of windows with >3 SNPs - lets look at those.
How manyt windows contain different numbers of SNPs?
```{r}
#nrow(unique(disc.sites.window[disc.sites.window$disc.sites>=8,]))

nrow(disc.sites.window[disc.sites.window$disc.sites>=8,])
nrow(disc.sites.window[disc.sites.window$disc.sites>=7,])
nrow(disc.sites.window[disc.sites.window$disc.sites>=6,])
nrow(disc.sites.window[disc.sites.window$disc.sites>=5,])
nrow(disc.sites.window[disc.sites.window$disc.sites>=4,])
nrow(disc.sites.window[disc.sites.window$disc.sites>=3,])
```
\
Look at this another way (distance of discriminatory variants from each other along the genome)
```{r, fig.width=10, fig.height=6}
FST.sublin.combined.sig.unique.sites.df <- data.frame(POS = FST.sublin.combined.sig.unique.sites)

FST.sublin.combined.sig.unique.sites.df$dist.to.previous.mutation <- c(0, sapply(2:length(FST.sublin.combined.sig.unique.sites.df$POS), function(x) FST.sublin.combined.sig.unique.sites[x] - FST.sublin.combined.sig.unique.sites[x-1]) )
  
  
FST.sublin.combined.sig.unique.sites.df <- FST.sublin.combined.TPAE.sig %>%
  left_join(FST.sublin.combined.sig.unique.sites.df)



# Plot distance of each variant from it's nearest neighbour (or rather, then next variant along the genome)
p.FST.sublin.combined.sig.unique.sites_genomic.pos.distance <- FST.sublin.combined.sig.unique.sites.df %>%
  filter(dist.to.previous.mutation!=0, population %notin% c("Nichols","SS14", "TPA", "TPE")) %>%
  distinct(POS, .keep_all = T) %>%
  ggplot(aes(x=POS, y=dist.to.previous.mutation)) + 
  geom_point(size=1, alpha=0.5) +
  theme_bw() + theme(text = element_text(size = 10)) +
  #coord_cartesian(xlim=c(0,SS14.aln.length)) +
  x.theme.axis.rotate.angle +
  scale_x_continuous(breaks=pretty) +
  scale_y_log10() +
  labs(x="Genome Position (NC_021508.1; (bp))", y="Distance to\nprevious site (bp)") +
  geom_hline(yintercept = 300, color="red") +
  labs(title=paste0("Genomic distance between discriminatory SNPs (n=",FST.sublin.combined.sig.unique.sites.df %>% filter(population %notin% c("Nichols","SS14", "TPA", "TPE")) %>% distinct(POS) %>% nrow(),")"))
p.FST.sublin.combined.sig.unique.sites_genomic.pos.distance

```

\
```{r, fig.width=10, fig.height=6}
# Let's look specifically at those ≤300 bp apart
FST.sublin.combined.sig.unique.sites.df %>% 
  filter(FST.sublin.combined.sig.unique.sites.df$dist.to.previous.mutation<=300) %>% 
  nrow()

p.FST.sublin.combined.sig.unique.sites_genomeDistance_within_300bp_of_each_other_point <- FST.sublin.combined.sig.unique.sites.df %>% 
  filter(population %notin% c("Nichols","SS14", "TPA", "TPE"), dist.to.previous.mutation<=500) %>%
  ggplot(aes(x=POS, y=dist.to.previous.mutation)) + 
  geom_point(size=1, alpha=0.5) +
  theme_bw() + theme(text = element_text(size = 10)) +
  #coord_cartesian(xlim=c(0,SS14.aln.length)) +
  x.theme.axis.rotate.angle +
  scale_x_continuous(breaks=pretty) +
  #scale_y_log10() +
  coord_cartesian(ylim=c(1,300)) +
  labs(x="Genome Position (NC_021508.1; (bp))", y="Distance to previous site (bp)") +
  geom_hline(yintercept = 300, color="red") +
  labs(title=paste0("Genomic distance between discriminatory SNPs ≤300bp apart (n=", FST.sublin.combined.sig.unique.sites.df %>% filter(FST.sublin.combined.sig.unique.sites.df$dist.to.previous.mutation<=300) %>% distinct(POS) %>% nrow(),")") )

p.FST.sublin.combined.sig.unique.sites_genomeDistance_within_300bp_of_each_other_point



FST.sublin.combined.sig.unique.sites.df %>%
  filter(population %notin% c("Nichols","SS14", "TPA", "TPE")) %>%
  filter(dist.to.previous.mutation<=300) %>%
  arrange(POS) %>% distinct() %>%
  ggplot(aes(x=POS, y=dist.to.previous.mutation, color=population)) + 
  geom_point(alpha=0.5, size=1) + 
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  x.theme.axis.rotate.angle +
  labs(x="Genome Position (NC_021508.1; (bp))", y="Distance to previous site (bp)") +
  scale_color_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Classification", na.value = 'grey95') +
  coord_cartesian(ylim=c(1,300)) +
  #facet_wrap(vars(population)) +
  labs(title=paste0("Genomic distance between discriminatory SNPs ≤300bp apart (n=", FST.sublin.combined.sig.unique.sites.df %>% filter(population %notin% c("Nichols","SS14", "TPA", "TPE"),FST.sublin.combined.sig.unique.sites.df$dist.to.previous.mutation<=300) %>% distinct(POS) %>% nrow(),")") )
  
```



## Ok, now we need to group these into positional clusters

Function to make a pairwise matrix of genomic positional distance
```{r}
######################################################################
make_genome_site_positional_matrix <- function(region.size) {
  FST.unique.sites.combo <- data.frame(t(combn(FST.sublin.combined.sig.unique.sites,2,simplify=T)),stringsAsFactors = F)
  colnames(FST.unique.sites.combo) <- c("site1","site2")
  
  FST.unique.sites.combo$genomic.distance <- abs(FST.unique.sites.combo$site1 - FST.unique.sites.combo$site2)
  
  # Make a character vector for vertices
  FST.unique.sites.combo$site1.s <- paste0("s",FST.unique.sites.combo$site1)
  FST.unique.sites.combo$site2.s <- paste0("s",FST.unique.sites.combo$site2)
  
  # identify SNP pairings within specifed size range (bp)
  FST.unique.sites.combo.near <- FST.unique.sites.combo[FST.unique.sites.combo$genomic.distance<=region.size,]
  
  return(FST.unique.sites.combo.near)
}
######################################################################
```

\
Now apply
```{r}
# identify SNP pairings within 300 bp
FST.sublin.combined.sig.unique.sites.combo.near <- make_genome_site_positional_matrix(300)
FST.sublin.combined.sig.unique.sites.combo.near

# How many key sites are clustered within specifed size range (bp)?
length(unique(c(FST.sublin.combined.sig.unique.sites.combo.near$site1.s,FST.sublin.combined.sig.unique.sites.combo.near$site2.s)))


```
\
Define a function to make a network 
```{r}
######################################################################
# Make network
make_positional_network <- function(pairwise.matrix){
  # make a network
  set.seed(1235)
  my.genomic.sites.network <- network(pairwise.matrix[,c("site1.s","site2.s")], matrix.type = "edgelist", ignore.eval = FALSE, directed = F)
  return(my.genomic.sites.network)
}
######################################################################
# Extract and label components within network
classify_network_components <- function(my.positional_network){
  # igraph to define and extract components
  my.genomic.sites.network.ig <- asIgraph(my.positional_network)
  my.genomic.sites.network.components <- data.frame(site1=network.vertex.names(my.positional_network), vertex.no=as.vector(V(my.genomic.sites.network.ig)), cluster=igraph::components(my.genomic.sites.network.ig)$membership)
  my.genomic.sites.network.components$region.cluster <- paste0("RC",my.genomic.sites.network.components$cluster)
  return(my.genomic.sites.network.components)
}
######################################################################
# Reformat network into one suitable for plotting in ggnetwork (plot separately to allow customisation)
prepare_networkgg_for_plotting <- function(my.positional_network){
  my.network.components <- classify_network_components(my.positional_network)
  my.genomic.sites.network.gg <- ggnetwork(my.positional_network, layout = "fruchtermanreingold")
  my.genomic.sites.network.gg <- plyr::join(my.genomic.sites.network.gg, data.frame(vertex.names=my.network.components$site1, region.cluster=my.network.components$region.cluster, stringsAsFactors = F), by="vertex.names", type="left") 
  return(my.genomic.sites.network.gg)
}
######################################################################


###########
genomic.sites.network <- make_positional_network(FST.sublin.combined.sig.unique.sites.combo.near)

genomic.sites.network.gg <- prepare_networkgg_for_plotting(genomic.sites.network)


# Visualise network
ggplot(genomic.sites.network.gg, aes(x = x, y = y, xend = xend, yend = yend)) + 
  geom_edges(alpha=0.25,curvature = 0, color='grey25') + 
  geom_nodes(size=3, alpha=0.5, aes(color=region.cluster)) +
  theme_blank() + theme(legend.position='none') +
  #scale_color_manual(breaks=paste0("RC",1:18)) +
  NULL

```
\
\
```{r}
genomic.sites.retained <- genomic.sites.network.gg[,c("vertex.names", "region.cluster")]
genomic.sites.retained$POS <- as.numeric(gsub("s","",genomic.sites.retained$vertex.names))
genomic.sites.retained <- unique(genomic.sites.retained[order(genomic.sites.retained$POS),])


# Add sites not included in a regional haplotype back in (i.e. singletons)
##
genomic.sites.retained.FSTpop <- left_join(FST.sublin.combined.TPAE.sig, genomic.sites.retained, by="POS") %>%
  distinct()
##

genomic.sites.retained.FSTpop$in.haplotype <- ifelse(is.na(genomic.sites.retained.FSTpop$region.cluster),"no","yes")
genomic.sites.retained.FSTpop$region.cluster <- ifelse(is.na(genomic.sites.retained.FSTpop$region.cluster),genomic.sites.retained.FSTpop$POS,genomic.sites.retained.FSTpop$region.cluster)

# How many sites were not included in a region haplotype?
genomic.sites.retained.FSTpop %>% filter(is.na(vertex.names)) %>% distinct(POS, .keep_all = T) %>% nrow()

```
\
\
How many discriminatory sites do we get per region haplotype?
```{r}
genomic.sites.in_haplotypes.counts <- genomic.sites.retained %>% 
  group_by(region.cluster) %>%
  summarise(Count=n()) %>%
  arrange(desc(Count))

genomic.sites.in_haplotypes.counts

sum(genomic.sites.in_haplotypes.counts$Count)

genomic.sites.retained %>% distinct(POS)
```
\
How many sites per region?
```{r}
genomic.sites.retained.FSTpop %>%
  distinct(POS, region.cluster, .keep_all = T) %>% 
  dplyr::group_by(region.cluster) %>%
  summarise(Count=n()) %>% 
  filter(Count!=1) %>%
  mutate(median=median(Count), mean(Count), max=max(Count), min=min(Count)) %>%
  arrange(desc(Count))

```

\
```{r}
# How many discriminatory sites do we retain (per population) using only this clustering

genomic.sites.retained.FSTpop %>% 
  dplyr::filter(sig=="sig") %>%
  distinct(POS, .keep_all = T) %>%
  group_by(in.haplotype) %>%
  summarise(count=n())


genomic.sites.retained.FSTpop %>% 
  dplyr::filter(sig=="sig") %>%
  dplyr::group_by(population) %>% 
  dplyr::summarise(count=n())

genomic.sites.retained.FSTpop %>% 
  dplyr::filter(sig=="sig") %>% 
  dplyr::filter(population=="sublin-1")

```

\
Look at Network by sublineages supported
```{r}
genomic.sites.network.gg__lineage.meta <- genomic.sites.network.gg %>% left_join(genomic.sites.retained.FSTpop %>% select(POS, vertex.names,population) %>% distinct(), by="vertex.names") %>% distinct(x, y, vertex.names, xend, yend, POS, .keep_all = T)

#%>% filter(population %notin% c("TPE","TPA","Nichols","SS14")

genomic.sites.network.gg__lineage.meta

p.clustered.site.network_by_sublin <- genomic.sites.network.gg__lineage.meta %>%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) + 
  geom_edges(alpha=0.25,curvature = 0, color='grey25') + 
  geom_nodes(size=2, alpha=0.5, aes(color=population)) +
  theme_blank() + theme.text.size +
  scale_color_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Lineage/Sublineage\nsupported", na.value = 'grey95') +
  theme(legend.position='right') + legend.size +
  NULL

p.clustered.site.network_by_sublin
```
\
Plot together
```{r}
#p.clustered.site.network_by_sublin
p.positional_disc_sites_clustered.site.network_by_sublin__combi <- plot_grid(p.FST.sublin.combined.sig.unique.sites_genomic.pos.distance + labs(title="A - Genomic Distance between Discriminatory SNPs"), p.clustered.site.network_by_sublin + labs(title="B - Network of Discriminatory SNPs ≤300bp apart"), ncol=1, rel_heights = c(1,2) )
p.positional_disc_sites_clustered.site.network_by_sublin__combi


#ggsave(plot=p.positional_disc_sites_clustered.site.network_by_sublin__combi, paste0(Ancillary_Figures_directory,"All-DiscSites_TPAE-sublineages_in_network_combi.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=200, height=200, device='pdf', dpi=400)

```



If we only use variants that are part of a haplotype, how much discrimination do we get?
```{r}
d.disc.sites.in.haplotype.per.sublineage <- genomic.sites.retained.FSTpop %>% 
  dplyr::filter(sig=="sig") %>%
  dplyr::filter(in.haplotype=="yes") %>%
  distinct(population, POS) %>%
  dplyr::group_by(population) %>% 
  dplyr::summarise(count=n()) %>%
  arrange(count)
d.disc.sites.in.haplotype.per.sublineage


p.disc.sites.per.sublineage__in.haplotypes.only_barplot <- d.disc.sites.in.haplotype.per.sublineage %>%
  filter(population %notin% c("TPA", "TPE")) %>%
  ggplot(aes(count, population, fill=population)) + 
  geom_barh(stat='identity', width=0.65) + 
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='top') +
  x.theme.axis.rotate.angle +
  labs(x="Site Count", y="Sublineage") + scale_x_continuous(breaks=pretty) +
  scale_fill_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Classification", na.value = 'grey95') + theme(legend.position = 'none')
p.disc.sites.per.sublineage__in.haplotypes.only_barplot
```
\
Ok, so some regions may need the inclusion of 'singleton' regions still. Meanwhile, we don't need to include every amplicon for some of the regions - way more discriminatory power than necessary.
\
\

```{r}
# that's a lot of haplotypes. Ok, lets see if we can remove any that only support a single population (but still retain sufficient discrimination)
genomic.sites.retained.FSTpop_pops_per_region <- genomic.sites.retained.FSTpop %>% 
  dplyr::filter(in.haplotype=="yes") %>% 
  dplyr::select(region.cluster, population) %>%
  dplyr::distinct() %>%
  dplyr::group_by(region.cluster) %>%
  dplyr::summarise(pop.count=n()) %>%
  dplyr::ungroup()
genomic.sites.retained.FSTpop_pops_per_region

```


\
\
Check size of potential region - may want to filter out vary big regions that need splitting into multiple amplicons

```{r}
all.genomic.sites.FSTpop.amplicon.boundaries <- genomic.sites.retained.FSTpop %>%
  dplyr::group_by(region.cluster) %>%
  dplyr::summarise(start=min(POS), end=max(POS), length=(end-start), big.amplicon=ifelse(length>=385,"yes","no")) %>%
  dplyr::arrange(start) 

all.genomic.sites.FSTpop.amplicon.boundaries %>%
  dplyr::filter(region.cluster=="RC195")

all.genomic.sites.FSTpop.amplicon.boundaries %>% dplyr::filter(big.amplicon=="no") %>% pull(region.cluster)


# Identify longer target regions. 
all.genomic.sites.FSTpop.long.amplicons <- all.genomic.sites.FSTpop.amplicon.boundaries %>% dplyr::filter(big.amplicon=="yes") %>% pull(region.cluster)
```
\
\
########################################
\
## Hierarchical selection loop
Complicated loop to hierarchically select regions based on how discriminatory they are
\
prepare data
```{r, fig.height=8, fig.width=8}
genomic.sites.retained.FSTpop.all.lengths <- genomic.sites.retained.FSTpop

# filter out long regions >385bp
genomic.sites.retained.FSTpop <- genomic.sites.retained.FSTpop %>% filter(region.cluster %notin% all.genomic.sites.FSTpop.long.amplicons)

genomic.sites.retained.FSTpop %>% distinct(region.cluster) %>% nrow() # 822 regions left



####
genomic.sites.retained.FSTpop_pops_per_region.with.singles <- genomic.sites.retained.FSTpop %>% 
  dplyr::select(region.cluster, population) %>%
  dplyr::distinct() %>%
  dplyr::group_by(region.cluster) %>%
  dplyr::summarise(pop.count=n()) %>%
  dplyr::ungroup()

genomic.sites.retained.FSTpop_regions_per_pop.with.singles <- genomic.sites.retained.FSTpop %>% 
  dplyr::select(region.cluster, population) %>%
  dplyr::distinct() %>%
  dplyr::group_by(population) %>%
  dplyr::summarise(region.count=n()) %>%
  dplyr::ungroup()
```
\
\

### Core selection loop
```{r}

###############################################################
# Core Phylo-Seq hierarchical selection loop
######################################################
# start to build a list of sites
hierarchical.FST.sites.to.keep <- NULL
# Create empty list of populations (sublineages) to be added to
#TPA.TPE.scheme.list.cumulative.counts <- data.frame(population=TPA.TPE.scheme.list,Cum.count=0)
TPA.TPE.scheme.list.cumulative.counts <- data.frame(population=c(paste0("sublin-",TPA.TPE.global.sublins.list), "TPE", "TPA", "Nichols","SS14"),Cum.count=0) 

# Set minimum number of supporting sites to aim for in each sublineage 
site.support.threshold <- 3

for (current.count in seq(14,1)){
  # within loop, create dataset based on how many pops each site is discriminatory for (many = better)
  pops_per_region.current <- genomic.sites.retained.FSTpop_pops_per_region.with.singles %>% dplyr::filter(pop.count==current.count)
  
  # Now filter dataset to only include those haplotypes and get counts per population
  region_and_pop_counts.current <- genomic.sites.retained.FSTpop %>% 
    dplyr::filter(region.cluster %in% pops_per_region.current$region.cluster) %>%
    dplyr::group_by(region.cluster, population) %>%
    dplyr::summarise(regions.per.pop=n()) %>%
    dplyr::ungroup()
  
  # How many pops are supported in the population if we included these?
  sites.per.region.current <- region_and_pop_counts.current %>%
    dplyr::group_by(population) %>% 
    dplyr::summarise(Count.per.region=n()) %>%
    dplyr::ungroup()
  
  # Combine with full list of all sites, and add to cumulative supporting site count
  sites.per.region.current.addCum <- left_join(TPA.TPE.scheme.list.cumulative.counts, sites.per.region.current, by='population') %>% 
    replace(is.na(.), 0) %>%
    dplyr::mutate(Cum.count.new=(Cum.count+Count.per.region)) %>%
    # if the region is not adding to the cumulative counts, reduce to 0
    dplyr::mutate(Cum.count.new.only=ifelse(Cum.count.new < site.support.threshold, Cum.count.new, 0),
           Cum.count.fixed=Cum.count+Cum.count.new.only, 
           keep.var=ifelse(Cum.count < site.support.threshold, "keep", "discard")) 
  
  # list of current populations to focus on
  pops.to.keep <- sites.per.region.current.addCum %>% 
    dplyr::filter(keep.var == "keep")
  
  # add cumulative 'fixed' total back into original spreadsheet (outside of loop)
  TPA.TPE.scheme.list.cumulative.counts$Cum.count <- sites.per.region.current.addCum$Cum.count.new
  
  region_and_pop_counts.current.tokeep <- 
    region_and_pop_counts.current %>% 
    dplyr::filter(population %in% pops.to.keep$population)
  
  # Get a list of sites from this dataset, and put into a new list
  hierarchical.FST.sites.to.keep <- unique(c(hierarchical.FST.sites.to.keep, unlist(unique(region_and_pop_counts.current.tokeep$region.cluster))))
}  

hierarchical.FST.sites.to.keep <- unique(hierarchical.FST.sites.to.keep)


genomic.sites.retained.FSTpop.dataframe <- genomic.sites.retained.FSTpop %>% 
  dplyr::filter(region.cluster %in% hierarchical.FST.sites.to.keep) %>% 
  dplyr::ungroup()

genomic.sites.retained.FSTpop.dataframe  
```

\
\
Look at what we got
```{r}
genomic.sites.retained.FSTpop.dataframe %>% distinct(region.cluster)

genomic.sites.retained.FSTpop.dataframe %>% 
  dplyr::group_by(population) %>%
  dplyr::summarise(count.sites=n()) %>%
  dplyr::mutate(level=ifelse(population %in% c("Nichols","SS14"),"TPA_Lineage", ifelse(population %in% c("TPA", "TPE"), "Subspecies", "TP_Sublineage"))) %>%
  dplyr::filter(level!="Subspecies") %>%
  dplyr::mutate(population= factor(population, levels=TP.FST_combined.cols$Population_sl)) %>%
  filter(level=="TP_Sublineage") %>%
  summarise(median=median(count.sites), max=max(count.sites), min=min(count.sites))
```

\
\
########################################
\
Plot sublinaege coverage using this scheme
```{r}
# Coverage per sublineage
p.FSTpop_retained.initial_AmpliSeq_scheme.sublin_coverage <- genomic.sites.retained.FSTpop.dataframe %>% 
  dplyr::group_by(population) %>%
  dplyr::summarise(count.sites=n()) %>%
  dplyr::mutate(level=ifelse(population %in% c("Nichols","SS14"),"TPA_Lineage", ifelse(population %in% c("TPA", "TPE"), "Subspecies", "TP_Sublineage"))) %>%
  dplyr::filter(level!="Subspecies") %>%
  dplyr::mutate(population= factor(population, levels=TP.FST_combined.cols$Population_sl)) %>%
  ggplot(aes(y=population, x=count.sites, fill=population)) +
  geom_barh(stat='identity', width=0.65) + 
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='top') +
  #scale_x_continuous(breaks=pretty) +
  scale_x_continuous(breaks=seq(0,120,10)) + 
  x.theme.axis.rotate.angle +
  labs(x="Site Count", y="Genomic Sublineage", title=paste0("Genomic Sublineage Coverage (n=",length(unique(genomic.sites.retained.FSTpop.dataframe$region.cluster)), " amplicons)"), fill="Genomic\nSublineage") +
  scale_fill_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Classification", na.value = 'grey95') + theme(legend.position = 'none') +
  facet_grid(level~., scales = 'free_y', space='free_y') + y.facet.text.rotate

p.FSTpop_retained.initial_AmpliSeq_scheme.sublin_coverage
```

\
Look at coverage by amplicon / region
```{r, fig.height=8, fig.width=6}
# coverage by amplicon
genomic.sites.retained.FSTpop.dataframe %>% 
  dplyr::group_by(region.cluster, population) %>%
  dplyr::summarise(count.sites=n()) %>%
  dplyr::mutate(level=ifelse(population %in% c("Nichols","SS14"),"TPA_Lineage", ifelse(population %in% c("TPA", "TPE"), "Subspecies", "TP_Sublineage"))) %>%
  dplyr::filter(level %notin% c("Subspecies", "TPA_Lineage")) %>%
  ggplot(aes(y=region.cluster, x=count.sites, fill=population)) +
  geom_barh(stat='identity', width=0.65) + 
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='top') +
  x.theme.axis.rotate.angle +
  labs(x="Site Count", y="Amplicon Region", title=paste0("Genomic Sublineage Coverage (n=",length(unique(genomic.sites.retained.FSTpop.dataframe$region.cluster)), " amplicons)"), fill="Genomic\nSublineage") +
  scale_fill_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Classification", na.value = 'grey95') + theme(legend.position = 'right')
```
\
\
Look at distribution of SNPs in genome
```{r, fig.height=4, fig.width=8}
genomic.sites.retained.FSTpop.dataframe.unique_sites <- data.frame(POS=sort(unique(genomic.sites.retained.FSTpop.dataframe$POS)))

genomic.sites.retained.FSTpop.dataframe.unique_sites$dist.to.previous.mutation <- c(0, sapply(2:length(genomic.sites.retained.FSTpop.dataframe.unique_sites$POS), function(x) genomic.sites.retained.FSTpop.dataframe.unique_sites$POS[x] - genomic.sites.retained.FSTpop.dataframe.unique_sites$POS[x-1]) )


genomic.sites.retained.FSTpop.dataframe %>%
  left_join(genomic.sites.retained.FSTpop.dataframe.unique_sites, by='POS') %>%
  arrange(POS) %>%
  filter(population %notin% c("Nichols","SS14", "TPA", "TPE")) %>%
  ggplot(aes(POS, dist.to.previous.mutation)) +
  geom_point(alpha=0.5, size=2, aes(color=region.cluster)) +
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='top') +
  x.theme.axis.rotate.angle +
  geom_line(aes(group=region.cluster), alpha=0.25) +
  theme(legend.position='none') +
  scale_y_log10() +
  scale_x_continuous(breaks=pretty) +
  labs(y="Genomic distance between SNPs", x="Genome Position") +
  labs(title="Genomic position of SNPs and Regions")
  
```
\
\
\
Try plotting original network with ellipses indicating selected regions
```{r}
p.clustered.site.network_by_sublin__retained.in.scheme.ellipses <- genomic.sites.network.gg__lineage.meta %>%
  mutate(region.cluster.filt=ifelse(vertex.names %in% unique(genomic.sites.retained.FSTpop.dataframe$vertex.names), region.cluster, NA)) %>%
  mutate(region.cluster.present=ifelse(is.na(region.cluster.filt), "missing","present")) %>%
  ggplot(aes(x = x, y = y, xend = xend, yend = yend)) + 
  geom_edges(alpha=0.25,curvature = 0, color='grey25') + 
  geom_nodes(size=2, alpha=0.5, aes(color=population)) +
  theme_blank() + theme.text.size +
  scale_color_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Lineage/Sublineage\nsupported", na.value = 'grey95', guide = guide_legend(order = 1, ncol=2) ) +
  theme(legend.key.size = unit(0.5,"line"),legend.position='right') +
  new_scale_color() +
  geom_mark_ellipse(aes(group=region.cluster.filt, color=region.cluster.present), expand=0.0115, linewidth=0.15, alpha=0.7) +
  scale_color_manual(breaks=c("missing","present"), values=c("transparent", "red"), guide = 'none') +
  theme(legend.position='right') + legend.size +
  NULL
p.clustered.site.network_by_sublin__retained.in.scheme.ellipses <- rasterize(p.clustered.site.network_by_sublin__retained.in.scheme.ellipses , layers='Point', dpi=400)

p.clustered.site.network_by_sublin__retained.in.scheme.ellipses
```
\
\
Ok, can we replot all SNPs against distance, but this time add information about what made it into the selected region clusters?
```{r, fig.width=10, fig.height=6}
# Plot distance of each variant from it's nearest neighbour (or rather, then next variant along the genome)
p.FST.sublin.combined.sig.unique.sites_genomic.pos.distance_markSelectedRegions <- FST.sublin.combined.sig.unique.sites.df %>%
  filter(dist.to.previous.mutation!=0, population %notin% c("Nichols","SS14", "TPA", "TPE")) %>%
  distinct(POS, .keep_all = T) %>%
  left_join(distinct(select(genomic.sites.retained.FSTpop.dataframe, POS, region.cluster)), by="POS") %>%
  mutate(selected.region=ifelse(is.na(region.cluster), "No","Yes")) %>%
  ggplot(aes(x=POS, y=dist.to.previous.mutation)) + 
  geom_point(size=1, alpha=0.5, aes(color=selected.region)) +
  scale_color_manual(breaks=c("Yes","No"), values=c("red", "grey5"), guide = 'none') +
  theme(legend.key.size = unit(0.5,"line"),legend.position='right') +
  new_scale_color() +
  theme_bw() + theme(text = element_text(size = 10)) +
  x.theme.axis.rotate.angle +
  scale_x_continuous(breaks=pretty) +
  scale_y_log10() +
  labs(x="Reference Genome Position of Discriminatory sites (bp)", y="Distance to\nprevious site (bp)") +
  geom_hline(yintercept = 300, color="blue") +
  geom_mark_ellipse(aes(group=region.cluster, color=selected.region), expand=0.005, linewidth=0.075, alpha=0.45) +
  scale_color_manual(breaks=c("Yes","No"), values=c("red", "transparent"), name="Selected\nRegion") +
  labs(title=paste0("Genomic distance between discriminatory SNPs (n=",FST.sublin.combined.sig.unique.sites.df %>% filter(population %notin% c("Nichols","SS14", "TPA", "TPE")) %>% distinct(POS) %>% nrow(),")")) +
  NULL
p.FST.sublin.combined.sig.unique.sites_genomic.pos.distance_markSelectedRegions <- rasterize(p.FST.sublin.combined.sig.unique.sites_genomic.pos.distance_markSelectedRegions , layers='Point', dpi=400)

p.FST.sublin.combined.sig.unique.sites_genomic.pos.distance_markSelectedRegions
```

Plot together
```{r, fig.height=8, fig.width=8}
p.positional_disc_sites_clustered.site.network_by_sublin.both_ellipses__combi <- plot_grid(p.FST.sublin.combined.sig.unique.sites_genomic.pos.distance_markSelectedRegions + labs(title="A - Genomic Distance between Discriminatory SNPs"), p.clustered.site.network_by_sublin__retained.in.scheme.ellipses + labs(title="B - Network of Discriminatory SNPs ≤300bp apart"), ncol=1, rel_heights = c(1,2) )
p.positional_disc_sites_clustered.site.network_by_sublin.both_ellipses__combi


#ggsave(plot=p.positional_disc_sites_clustered.site.network_by_sublin.both_ellipses__combi, paste0(Figures_directory,"Figure2__DiscSites_clustered.site.network_ellipses.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=220, height=220, device='pdf', dpi=400)

```
\
\
\
Define boundaries of region clusters we are keeping and make a bed file
```{r}
#genomic.sites.retained.FSTpop
mp.max.length <- 700
genomic.sites.retained.FSTpop.amplicon.boundaries <- genomic.sites.retained.FSTpop.dataframe %>%
  dplyr::group_by(region.cluster) %>%
  dplyr::summarise(start=min(POS), end=max(POS), length=(end-start), mp.extra.to.add=ceiling((mp.max.length-length)/2), 
            start.extra=start-mp.extra.to.add, end.extra=end+mp.extra.to.add, length.extra=(end.extra-start.extra), length.adjust=ifelse(length==0,1,length)) %>%
  dplyr::arrange(start.extra)


#genomic.sites.retained.FSTpop.amplicon.boundaries$chromosome <- "CP004010" #To use Nichols reference genome
genomic.sites.retained.FSTpop.amplicon.boundaries$chromosome <- "NC_021508_1_1" #To use SS14 reference genome

genomic.sites.retained.FSTpop.amplicon.boundaries$bed.bounds <- sapply(1:nrow(genomic.sites.retained.FSTpop.amplicon.boundaries), function(x) paste0(as.character(genomic.sites.retained.FSTpop.amplicon.boundaries$mp.extra.to.add[x]),",",genomic.sites.retained.FSTpop.amplicon.boundaries$length.adjust[x]))

genomic.sites.retained.FSTpop.amplicon.boundaries.bedfile <- genomic.sites.retained.FSTpop.amplicon.boundaries %>%
  select(chromosome, start.extra, end.extra, region.cluster, bed.bounds)

genomic.sites.retained.FSTpop.amplicon.boundaries.bedfile

#write.table(genomic.sites.retained.FSTpop.amplicon.boundaries.bedfile, file="/Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/Gubbins_on-SS14-mapped/FST.sublin.combined.TPAE-discriminatory-sites_500bp.20220615.bed", sep = "\t", col.names=F, row.names=F, quote=F)
```
\
\
\
# Primer design with primalscheme
Generate list of regions, for input into primal scheme
\
```{r}
# want a comma delimited file in the format <start>,<end>,<regionname>
ps.max.length <- 684 
genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme.int <- genomic.sites.retained.FSTpop.amplicon.boundaries %>%
  dplyr::select(start, end, length, region.cluster) %>%
  dplyr::mutate(ps.extra.to.add=ceiling((ps.max.length-length)/2)) %>%
  dplyr::mutate(ps.start=start-ps.extra.to.add, ps.end=end+ps.extra.to.add, ps.length=ps.end-ps.start,
ps.mask.start=(ps.extra.to.add-30),
ps.mask.end=(ps.mask.start+length+30), 
ps.mask.length=ps.mask.end-ps.mask.start)
  
genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme <- genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme.int %>%
  select(ps.start, ps.end, region.cluster)

genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme

#write.table(genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme, file="/Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/Gubbins_on-SS14-mapped/FST.sublin.combined.TPAE-discriminatory-sites_684bp.20220613.primalscheme.csv", sep = ",", col.names=F, row.names=F, quote=F)

genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme.masking <- genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme.int %>%
  select(region.cluster, ps.mask.start, ps.mask.end)

#write.table(genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme.masking, file="/Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/Gubbins_on-SS14-mapped/FST.sublin.combined.TPAE-discriminatory-sites_684bp.20220613.primalscheme.site-masking.csv", sep = ",", col.names=F, row.names=F, quote=F)

```
\ 
\
After primalscheme design, read in file so we can do in silico PCR
```{r}
primalscheme.design <- read.delim(primalscheme.design.file, sep="\t", header=T)
primalscheme.design.bed <- read.table(primalscheme.design.bed.file, sep="\t", check.names = F, col.names = c("Region_cluster", "primer_start", "primer_end", "weird_name","primer_number","strand"))

primalscheme.design$region <- gsub("\\_RIGHT","", gsub("\\_LEFT", "", primalscheme.design$name))
primalscheme.design$primer_side <- gsub("^.+\\_", "", primalscheme.design$name)
primalscheme.design

primalscheme.design %>% summarise(meanTm = mean(`tm..use.65.`), maxTm=max(`tm..use.65.`), minTm=min(`tm..use.65.`) )



primalscheme.design.table <- primalscheme.design %>% 
  pivot_wider(names_from="primer_side", values_from="seq", -c(name, size, X.gc,tm..use.65.)) %>%
  select(region, LEFT, RIGHT)
primalscheme.design.table
  
#write.table(primalscheme.design.table, file="/Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/Gubbins_on-SS14-mapped/primalscheme.684/TP.disc.primalscheme.primerset.684_20220613.tsv", sep = "\t", col.names=F, row.names=F, quote=F)
```

\ 
Get some statistics about those primers
```{r}
sum(nchar(unlist(primalscheme.design.table$LEFT[]))) + sum(nchar(unlist(primalscheme.design.table$RIGHT[])))

max(nchar(unlist(primalscheme.design.table$LEFT[])))
min(nchar(unlist(primalscheme.design.table$LEFT[])))
max(nchar(unlist(primalscheme.design.table$RIGHT[])))
min(nchar(unlist(primalscheme.design.table$RIGHT[])))
```

\
Ordering primers:
100 nmole DNA Oligo


ODT: 



\ 
Need to correlate the defined regions with the actual positions in the genome
```{r}
# read in primer binding locations file
SS14.primer_binding.locations <- read.table(SS14.primer_binding.locations.file, sep="\t", col.names=c("pcr.region", "refgenome","amplicon.start","amplicon.end"))


# Create iranges object for SS14 primer locations
SS14.primer_binding.locations.iranges <- IRanges(SS14.primer_binding.locations$amplicon.start,SS14.primer_binding.locations$amplicon.end, names=SS14.primer_binding.locations$pcr.region)
# Create IRanges object for primal scheme region locations
genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme.iranges <- IRanges(genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme$ps.start,genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme$ps.end, names=genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme$region.cluster)

# Find overlaps using IRanges (outputs a matrix of hits)
SS14.primer_binding.locations.iranges.genehits <- IRanges::findOverlaps(SS14.primer_binding.locations.iranges, genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme.iranges)
SS14.primer_binding.locations.iranges.genehits <- as.matrix(SS14.primer_binding.locations.iranges.genehits)

# Extract the various sample names from each side of the intersect and merge
SS14.primer_binding.locations.iranges.genehits.match <- left_join(
  data.frame(cbind(SS14.primer_binding.locations.iranges.genehits,SS14.primer_binding.locations[SS14.primer_binding.locations.iranges.genehits[,1],])) , 
  data.frame(cbind(SS14.primer_binding.locations.iranges.genehits,genomic.sites.retained.FSTpop.amplicon.boundaries.primalscheme[SS14.primer_binding.locations.iranges.genehits[,2],])), by=c("queryHits", "subjectHits")) %>%
  select(region.cluster, pcr.region, ps.start, ps.end, amplicon.start, amplicon.end) %>%
  mutate(ps.length=ps.end-ps.start, amplicon.length=amplicon.end-amplicon.start) %>% # note that 'amplicon' refers to the 'insert' here (i.e flanked by primers)
  arrange(ps.start) 

SS14.primer_binding.locations.iranges.genehits.match <- left_join(SS14.primer_binding.locations.iranges.genehits.match, primalscheme.design.table, by=c("pcr.region"="region")) 

SS14.primer_binding.locations.iranges.genehits.match
```
\
Do some stats about lengths
```{r}
SS14.primer_binding.locations.iranges.genehits.match %>% summarise(mean.PCRproduct.length = mean(ps.length), max.PCRproduct.length = max(ps.length), min.PCRproduct.length = min(ps.length))
```

\
Now read in results of in silico PCR (a tab delimited file resulting from greping the fasta headers in a loop)
`grep '>' all_*.fasta | perl -pe 's/\:\>/\t/g' > in_silico_pcr.amplicon.recovery_list.tsv`
\
```{r, fig.height=12, fig.width=12}
# Read in results of in silico pcr
in_silico_pcr.results <- read.table(in_silico_pcr.results.file, sep="\t", col.names = c("pcr_region","Sample"), comment.char = "")
in_silico_pcr.results

ggplot(in_silico_pcr.results, aes(pcr_region, Sample)) +
  geom_point(size=1, alpha=0.5)


in_silico_pcr.results %>% 
  dplyr::group_by(pcr_region) %>%
  dplyr::summarise(Count=n()) %>%
  dplyr::ungroup() %>% 
  dplyr::mutate(order=as.numeric(gsub("\\.fasta","", gsub("all\\_","",pcr_region)))) %>%
  dplyr::mutate(region=gsub("\\.fasta","",pcr_region)) %>%
  right_join(primalscheme.design.table, by="region") %>% 
  #arrange(order) %>% 
  dplyr::arrange(Count) %>% 
  dplyr::mutate(pcr_region=factor(pcr_region, levels=unique(pcr_region)), region=factor(region, levels=unique(region))) %>%
  ggplot(aes(y=region,x=Count)) +
  geom_barh(stat='identity')
```
\
\
Do some counting
```{r}
in_silico_pcr.results %>% 
  group_by(pcr_region)
```

\
Look further at the poor ones
c("all_2","all_56","all_10","all_5", "all_67", "all_22")
```{r}

primalscheme.design %>% filter(region %in% c("all_2","all_56","all_10","all_5", "all_67", "all_22"))
SS14.primer_binding.locations.iranges.genehits.match %>% filter(pcr.region %in% c("all_2","all_56","all_10","all_5", "all_67", "all_22")) %>% select(region.cluster) %>% pull()


cant.make.list2 <- c("RC148","RC282","RC94",SS14.primer_binding.locations.iranges.genehits.match %>% filter(pcr.region %in% c("all_2","all_56","all_10","all_5", "all_67", "all_22")) %>% select(region.cluster) %>% pull())

revised.amplicon.count <- genomic.sites.retained.FSTpop.dataframe %>% 
  dplyr::filter(region.cluster %notin% cant.make.list2) %>%
  dplyr::distinct(region.cluster) %>%
  dplyr::group_by(region.cluster) %>% 
  dplyr::summarise(n.rcs=n()) %>%
  nrow()
revised.amplicon.count


```

\
Ok, lets see if we can figure out why there are fewer successful amplicons for some regions - can use the positions of the primers to extract regions from the MSA
```{r}
SS14.primer_binding.locations.iranges.genehits.match <- SS14.primer_binding.locations.iranges.genehits.match %>% mutate(amplicon.region.pos.cat=paste0(amplicon.start, ",", amplicon.end, ",", pcr.region,"__(",region.cluster,")"))
SS14.primer_binding.locations.iranges.genehits.match


SS14.primer_binding.locations.regions.2.extract <- SS14.primer_binding.locations.iranges.genehits.match %>% select(amplicon.start, amplicon.end, pcr.region)

#write.csv(SS14.primer_binding.locations.regions.2.extract, file="/Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/Gubbins_on-SS14-mapped/primalscheme.684/FST.sublin.combined.TPAE-discriminatory-sites_684bp-primer-binding-sites.20220620.csv", col.names=F, row.names=F, quote=F)
  
```
\
So looking at amplicon `all_56`, a portion of samples from the masked/gubbins alignment are masked at the forward primer binding sites... Is there something about those samples? Can't see an obvious gene hit (TPASS_RS00470, TPASS_RS00475), nor in the gubbins masking file (could have missed it) or in the pre-masking file used when building alignment.
```{r}

# properly adjust for missing amplicons
left_join(data.frame(Sample=unique(in_silico_pcr.results$Sample)), (in_silico_pcr.results %>% filter(pcr_region=="all_56.fasta")), by="Sample") %>%
  left_join((TPAE.pinecone.10 %>% select(Taxa, TPA.TPE.scheme)), by=c("Sample"="Taxa")) %>%
  dplyr::mutate(amplicon.56.present=ifelse(is.na(pcr_region),"0","1")) %>%
  dplyr::group_by(pcr_region, TPA.TPE.scheme, amplicon.56.present) %>%
  dplyr::summarise(count=n()) %>%
  ggplot(aes(y=TPA.TPE.scheme, x=count, fill=amplicon.56.present)) +
  geom_barh(stat='identity') + 
  theme_bw() + theme.text.size
  
  # So we don't get some sublineages at all c("6", "15", "TPE26", "TPE40"), and some sublineages don't do well c("1","14","TPE20", )
```

\
```{r}
# What happens to the scheme if we don't include these amplicons?
genomic.sites.retained.FSTpop.dataframe %>% 
  dplyr::filter(region.cluster %notin% cant.make.list2) %>%
  dplyr::group_by(population) %>%
  dplyr::summarise(count.sites=n()) %>% 
  dplyr::mutate(level=ifelse(population %in% c("Nichols","SS14"),"TPA_Lineage", ifelse(population %in% c("TPA", "TPE"), "Subspecies", "TP_Sublineage"))) %>%
  dplyr::filter(level!="Subspecies") %>%
  dplyr::mutate(population= factor(population, levels=TP.FST_combined.cols$Population_sl)) %>%
  ggplot(aes(y=population, x=count.sites, fill=population)) +
  geom_barh(stat='identity', width=0.65) + 
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='top') + 
  scale_x_continuous(breaks=seq(0,120,5)) + 
  labs(x="Site Count", y="Genomic Sublineage", title=paste0("Genomic Sublineage Coverage (n=",revised.amplicon.count, " amplicons)"), fill="Genomic\nSublineage") +
  x.theme.axis.rotate.angle +
  scale_fill_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Classification", na.value = 'grey95') + theme(legend.position = 'none') +
  facet_grid(level~., scales = 'free_y', space='free_y') + y.facet.text.rotate

```
\
```{r}
# Not too bad
# Ok, what does "all_2" (complete in silico failure) actually add to the scheme? - Nothing (already excluded)
SS14.primer_binding.locations.iranges.genehits.match %>% filter(pcr.region=="all_2")
# Ok, what does "all_56" (moderate in silico failure) actually add to the scheme?
SS14.primer_binding.locations.iranges.genehits.match %>% filter(pcr.region=="all_56")  
SS14.primer_binding.locations.iranges.genehits.match %>% filter(pcr.region=="all_56") %>% select(region.cluster) %>% pull()
genomic.sites.retained.FSTpop.dataframe %>% filter(region.cluster %in% (SS14.primer_binding.locations.iranges.genehits.match %>% filter(pcr.region=="all_56") %>% select(region.cluster) %>% pull()))


# Ok, what do the others actually add to the scheme?
genomic.sites.retained.FSTpop.dataframe %>% filter(region.cluster %in% (SS14.primer_binding.locations.iranges.genehits.match %>% filter(pcr.region %in% c("all_56","all_10","all_5", "all_67", "all_22")) %>% select(region.cluster) %>% pull())) %>% arrange(population, region.cluster)

```


## 2022-11-23
\
### Exclusion of lab failures/underperformers
Results from lab analysis have identified some amplicons which perform poorly:
\
Complete (or near complete) failure in single plex for:
all_1
\
V. poor performance for 
all_16
all_9
all_67
all_38
\
Suboptimal performance for 
all_37
all_53
all_73
\
Good performance for
all_20
all_40
all_49
all_71
\
\
What would be the effect on the scheme of losing those amplicons? 
```{r, fig.width=6, fig.height=6}
lab.amplicon.underperforming.failure.list <- c("all_1","all_16","all_9","all_67","all_38","all_37","all_53","all_73")
lab.amplicon.underperforming.failure.list.regions <- SS14.primer_binding.locations.iranges.genehits.match %>%
  filter(pcr.region %in% lab.amplicon.underperforming.failure.list) %>% select(region.cluster) %>% pull()


lab.amplicon.failure.list <- c("all_1","all_16","all_9","all_67","all_38","all_37")
lab.amplicon.failure.list.regions <- SS14.primer_binding.locations.iranges.genehits.match %>%
  filter(pcr.region %in% lab.amplicon.failure.list) %>% select(region.cluster) %>% pull()


revised.amplicon.count.if.all.bad.amplicon.failure <- genomic.sites.retained.FSTpop.dataframe %>% 
  dplyr::filter(region.cluster %notin% lab.amplicon.underperforming.failure.list.regions) %>%
  dplyr::distinct(region.cluster) %>%
  dplyr::group_by(region.cluster) %>% 
  dplyr::summarise(n.rcs=n()) %>%
  nrow()
revised.amplicon.count.if.all.bad.amplicon.failure

revised.amplicon.count.if.weaker.bad.amplicon.failure <- genomic.sites.retained.FSTpop.dataframe %>% 
  dplyr::filter(region.cluster %notin% lab.amplicon.failure.list.regions) %>%
  dplyr::distinct(region.cluster) %>%
  dplyr::group_by(region.cluster) %>% 
  dplyr::summarise(n.rcs=n()) %>%
  nrow()
revised.amplicon.count.if.weaker.bad.amplicon.failure


# What happens to the scheme if all these amplicons drop out?
p.bar.sublineage.coverage.if.all.bad.amplicon.failure <- genomic.sites.retained.FSTpop.dataframe %>% 
  dplyr::filter(region.cluster %notin% lab.amplicon.underperforming.failure.list.regions) %>%
  dplyr::group_by(population) %>%
  dplyr::summarise(count.sites=n()) %>% 
  dplyr::mutate(level=ifelse(population %in% c("Nichols","SS14"),"TPA_Lineage", ifelse(population %in% c("TPA", "TPE"), "Subspecies", "TP_Sublineage"))) %>%
  dplyr::filter(level!="Subspecies") %>%
  dplyr::mutate(population= factor(population, levels=TP.FST_combined.cols$Population_sl)) %>%
  ggplot(aes(y=population, x=count.sites, fill=population)) +
  geom_barh(stat='identity', width=0.65) + 
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='top') + 
  scale_x_continuous(breaks=seq(0,120,5)) + 
  labs(x="Site Count", y="Genomic Sublineage", title=paste0("Genomic Sublineage Coverage (n=",revised.amplicon.count.if.all.bad.amplicon.failure, " amplicons)\n- all bad amplicons lost"), fill="Genomic\nSublineage") +
  x.theme.axis.rotate.angle +
  scale_fill_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Classification", na.value = 'grey95') + theme(legend.position = 'none') +
  facet_grid(level~., scales = 'free_y', space='free_y') + y.facet.text.rotate
 
p.bar.sublineage.coverage.if.all.bad.amplicon.failure
```

So this doesn't really lose any sublineages 
\
```{r, fig.height=6, fig.width=10}
# What happens to the scheme if we can tweak the weaker ones, but lose the others?
p.bar.sublineage.coverage.if.weaker.bad.amplicon.failure <- genomic.sites.retained.FSTpop.dataframe %>% 
  dplyr::filter(region.cluster %notin% lab.amplicon.failure.list.regions) %>%
  dplyr::group_by(population) %>%
  dplyr::summarise(count.sites=n()) %>% 
  dplyr::mutate(level=ifelse(population %in% c("Nichols","SS14"),"TPA_Lineage", ifelse(population %in% c("TPA", "TPE"), "Subspecies", "TP_Sublineage"))) %>%
  dplyr::filter(level!="Subspecies") %>%
  dplyr::mutate(population= factor(population, levels=TP.FST_combined.cols$Population_sl)) %>%
  ggplot(aes(y=population, x=count.sites, fill=population)) +
  geom_barh(stat='identity', width=0.65) + 
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='top') + 
  scale_x_continuous(breaks=seq(0,120,5)) + 
  labs(x="Site Count", y="Genomic Sublineage", title=paste0("Genomic Sublineage Coverage (n=",revised.amplicon.count.if.weaker.bad.amplicon.failure, " amplicons)\n- weakest amplicons lost, some optimisation"), fill="Genomic\nSublineage") +
  x.theme.axis.rotate.angle +
  scale_fill_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Classification", na.value = 'grey95') + theme(legend.position = 'none') +
  facet_grid(level~., scales = 'free_y', space='free_y') + y.facet.text.rotate



p.bar.sublineage.coverage.if.all.bad.amplicon.failure
p.bar.sublineage.coverage.if.weaker.bad.amplicon.failure

plot_grid(p.bar.sublineage.coverage.if.weaker.bad.amplicon.failure, p.bar.sublineage.coverage.if.all.bad.amplicon.failure + y.theme.strip, ncol=2, align='h', axis='h', rel_widths = c(6,5))

```

```{r}
# Ok, what do the weak amplicons actually add to the scheme?
genomic.sites.retained.FSTpop.dataframe %>% filter(region.cluster %in% (SS14.primer_binding.locations.iranges.genehits.match %>% filter(pcr.region %in% lab.amplicon.underperforming.failure.list) %>% select(region.cluster) %>% pull())) %>% arrange(population, region.cluster)

# And what is the benefit of doing the extra optimisation?
genomic.sites.retained.FSTpop.dataframe %>% filter(region.cluster %in% (SS14.primer_binding.locations.iranges.genehits.match %>% filter(pcr.region %in% lab.amplicon.underperforming.failure.list[lab.amplicon.underperforming.failure.list %notin% lab.amplicon.failure.list]) %>% select(region.cluster) %>% pull())) %>% arrange(population, region.cluster)
# so the two amplicons that are easy to resolve are actually not that helpful anyway - they only inform on TPE sites or species sites
```


\
\ 
Ok, do some further validation using primer blast (primerTree)
\
This takes a long time to do properly, so is commented out. Precalculated values are available. 
```{r, fig.height=10, fig.width=10, eval=F}
#registerDoMC(4)

#SS14.primer_binding.locations.iranges.genehits.match$LEFT[1]

my.ncbi.api.key <- my.ncbi.api.key.id

#primer.search.output.all <- NULL 
#for (current in 1:nrow(SS14.primer_binding.locations.iranges.genehits.match[,])){
#  print(paste0("(",current,") ", "searching against amplicon ", SS14.primer_binding.locations.iranges.genehits.match$pcr.region[current]))
#  primer.search.output1 <- parse_primer_hits(primer_search(SS14.primer_binding.locations.iranges.genehits.match$LEFT[current], SS14.primer_binding.locations.iranges.genehits.match$RIGHT[current])$`1`)
#  primer.search.output1.taxon <- get_taxonomy(primer.search.output1$accession)
#  primer.search.output1 <- left_join(primer.search.output1, primer.search.output1.taxon, by="accession")
#  primer.search.output1 <- primer.search.output1 %>% select(c("accession", "product_length", "mismatch_forward", "mismatch_reverse", "forward_start", "forward_stop", "reverse_start", "reverse_stop", "product_start", "product_stop", "taxId", "subspecies", "superkingdom", "phylum", "class", "order", "family", "genus", "species"))
#  primer.search.output1$amplicon <- SS14.primer_binding.locations.iranges.genehits.match$pcr.region[current]
#  primer.search.output1$region.cluster <- SS14.primer_binding.locations.iranges.genehits.match$region.cluster[current]
#  primer.search.output.all <- rbind(primer.search.output.all, primer.search.output1)
#}


#write.table(primer.search.output.all, file="/Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/Gubbins_on-SS14-mapped/primalscheme.684/TP.disc.primalscheme.primerset.684__primerBLAST_20220616.tsv", sep = "\t", col.names=T, row.names=F, quote=F)
```

\
```{r, fig.height=10, fig.width=10}
# Read in precalculated primer blast searches
primer.search.output.all2 <- read.table(primer.search.output.all2.file, sep = "\t", check.names = F, header=T, comment.char='')

# Lots of timeouts in loop - looks like a few of the amplicons have been run twice - deduplicate hits for the same amplicon to deal with this 
primer.search.output.all2 <- primer.search.output.all2 %>% distinct(accession, amplicon, .keep_all = TRUE)

#primer.search.output.all.test <- full_join(primer.search.output.all, primer.search.output1)
p.primer.blast.barcount <- ggplot(primer.search.output.all2, aes(y=amplicon , fill=species)) + 
  geom_barh(stat='count', width=0.6, position='stack') +
  theme_bw() + theme.text.size + scale_x_continuous(breaks=pretty) +
  theme(legend.key.size = unit(0.55,"line")) +
  scale_fill_viridis_d() + 
  x.theme.axis.rotate.angle +
  labs(x="Primer BLAST hits\n(<=3 mismatches, 500 max)", y="PCR Amplicon", fill="Species")  +
  labs(title="A - Top BLAST matches")
#p.primer.blast.barcount

p.primer.blast.size <- ggplot(primer.search.output.all2, aes(y=amplicon, x=product_length, color=species)) + 
  geom_quasirandom_rast(size=1.25, alpha=0.5, width=0.3, groupOnX = F) +
  #geom_quasirandom(size=1.5, alpha=0.5, width=0.3, orientation = 'y') +
  theme_bw() + theme.text.size + 
  scale_x_continuous(breaks=c(0,250,500, 750,1000,1500,2000,2500,3000,4000,5000,7500), expand=c(0,0)) +
  labs(y="PCR amplicon", x="PCR product length\n(bp)", colour="Species") +
  theme(legend.key.size = unit(0.55,"line")) +
  scale_color_viridis_d(guide = guide_legend(order = 1, ncol=1)) +
  x.theme.axis.rotate.angle +
  labs(title="B - Predicted amplicon size\nfor BLAST matches")
#p.primer.blast.size

p.primerblast.hits <- plot_grid(p.primer.blast.barcount + theme(legend.position='none'), p.primer.blast.size + y.theme.strip, ncol=2, align="h", axis="tbl", rel_widths = c(1,2), vjust=0.975, label_x=c(-0.1,-0.1), scale=0.95)
p.primerblast.hits

#ggsave(plot=p.primerblast.hits, paste0(Ancillary_Figures_directory,"PrimerBLAST.hits.73-amplicon-scheme",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=200, height=200, device='pdf', dpi=600)

```
\
A number of off-target hits (albeit small). What are those organisms?
```{r}

primer.blast.species.hits <- primer.search.output.all2 %>% 
  select(species,superkingdom, phylum, class, order, family) %>%
  na.omit() %>%
  distinct()
#primer.blast.species.hits

# Look up common name from scientific name using `taxize` package (doesn't find everything)

#t.common_name <- sci2comm(primer.blast.species.hits$species, db = "ncbi", simplify = TRUE)
#primer.blast.species.hits$common_name <- gsub("character\\(0\\)",NA, as.character(t.common_name))
#primer.blast.species.hits <- select(primer.blast.species.hits, common_name, species,superkingdom, phylum, class, order, family)


#write.table(primer.blast.species.hits, file="/Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/Gubbins_on-SS14-mapped/primalscheme.684/TP.disc.primalscheme.primerset.684__primerBLAST_species-hits_20220620.tsv", sep = "\t", col.names=T, row.names=F, quote=F)

#
#
#############################################################
# This takes a while - read in precalculated results
primer.blast.species.hits <- read.table(primer.blast.species.hits.precalc.file, sep = "\t", check.names = F, header=T, comment.char='')

primer.blast.species.hits
```
\
Ok, these are all Eukaryotes, and searches and manual checks found nothing to worry about in any sample we might test (apart from potentially mouse)

\
Now output final primer pool (for discriminatory alleles)
```{r}
discriminatory.primer_designs.output <- SS14.primer_binding.locations.iranges.genehits.match %>% 
  mutate(amplicon.region.pos.cat=paste0(amplicon.start, "_", gsub("\\_","-",pcr.region))) %>%
  select(amplicon.region.pos.cat, LEFT, RIGHT) %>%
  pivot_longer(names_to="direction", values_to="sequence", -amplicon.region.pos.cat) %>%
  mutate(primer_N=ifelse(direction=="LEFT","1","2") , 
         amplicon.dir=paste0(amplicon.region.pos.cat, "_",primer_N)) %>%
  select(amplicon.dir, sequence)

discriminatory.primer_designs.output


#write.table(discriminatory.primer_designs.output, file="/Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/Gubbins_on-SS14-mapped/primalscheme.684/discriminatory.primer_designs.final.20220624.tsv", quote=F, col.names=T, row.names=F, sep="\t")
```
\
Get information of primer scheme
```{r}
# How many primer sets at this point?
discriminatory.primer_designs.output %>% 
  mutate(amplicon.nam = gsub("\\_2$","",gsub("\\_1$","",amplicon.dir))) %>%
  group_by(amplicon.nam) 
```

\
\
\
\
# 23S Ribosomal amplicons (for macrolide resistance)
Need to define a new set of primers for 23S that will be compatible with the discriminatory AmpliSeq scheme. 
\
\
Lets look at making a decent amplicon set for 23S
\
Need to identify conserved regions (will use the 661K COBS search) - must be highly conserved to Treponema, to minimimise off-target amplification in mixed speciments. 
```{r}
TPA.refseq <- seqinr::read.fasta(file=TPA.refseq.file, seqtype="DNA", as.string=T,set.attributes=F)

# Capture and relabel the sequence names and make them pretty 
#names(TPA.refseq)
TPA.refseq.aln <- data.frame((as.matrix.alignment(seqinr::as.alignment(nb=length(names(TPA.refseq)),nam=NULL,seq=TPA.refseq,com=NULL))), stringsAsFactors = F)

# Generate 71bp sliding windows (minimum query length) along the reference, incrementing by 1 each time
querysize <- 71
window.method <- seq(1,(ncol(TPA.refseq.aln)-querysize),10)
TPA.refseq.makewindows <- data.frame(window.start=window.method,stringsAsFactors=F)
TPA.refseq.makewindows$window.centre <- (window.method+floor(querysize/2))
TPA.refseq.makewindows$sequence <- toupper(sapply(window.method, function(x) paste(TPA.refseq.aln[,c(x:(x+(querysize-1)))],collapse="")))
TPA.refseq.makewindows$querysize <- querysize

TPA.refseq.makewindows$window.start.genomepos <- TPA.refseq.makewindows$window.start + 233094
TPA.refseq.makewindows$window.end.genomepos <- TPA.refseq.makewindows$window.start + querysize + 233094
TPA.refseq.makewindows$windowid <- paste0("23S__",TPA.refseq.makewindows$window.start.genomepos,"-",TPA.refseq.makewindows$window.end.genomepos)

TPA.refseq.makewindows$seq.test.length <- nchar(TPA.refseq.makewindows$sequence)


# Create file name for fasta output
#TP23S.fasta.out.filename <- paste0("/Users/mb29/Treponema/Treponema_References/23S_alleles/23S_Nichols_2-operons1.",querysize,"bp-windows.",format(Sys.Date(),"%Y%m%d"),".fa")

#for (current.sample in c(1:length(TPA.refseq.makewindows$windowid))){
#  seqinr::write.fasta(names=TPA.refseq.makewindows$windowid[current.sample], sequences = TPA.refseq.makewindows$sequence[current.sample], file.out = TP23S.fasta.out.filename,open="a", as.string = T)
#}
```
\
\

Run 661K COBS search to find identical hits (100% kmer identity)
`query_COBS_image.sh -t 1 23S_Nichols_2-operons1.71bp-windows.20220623.fa`
Then import results file and link to species metadata
```{r, fig.width=10, fig.height=6}
# Files pre-calculated using COBS search of Blackwell 661K dataset
# COBS661K_window.search.23S.file
# COBS661K.metadata.file

COBS661K_window.search.23S <- read.csv(COBS661K_window.search.23S.file, sep="\t", header=T)
COBS661K.metadata <- read.csv(COBS661K.metadata.file, sep="\t", header=T)

COBS661K_window.search.23S <- left_join(COBS661K_window.search.23S, COBS661K.metadata, by="sample_id")

COBS661K_window.search.23S$window.start <- as.numeric(gsub("\\-.+$","",gsub("23S\\_\\_","",COBS661K_window.search.23S$query)))
COBS661K_window.search.23S$window.end <- as.numeric(gsub("^.+\\-","",gsub("23S\\_\\_","",COBS661K_window.search.23S$query)))
COBS661K_window.search.23S$window.midpoint <- (COBS661K_window.search.23S$window.start + ceiling((COBS661K_window.search.23S$window.end-COBS661K_window.search.23S$window.start)/2))


COBS661K_window.search.23S %>%
  group_by(major_species) %>%
  summarise(Species_count=n()) %>%
  arrange(desc(Species_count))


p.COBS661K_window.search.23S_all <- COBS661K_window.search.23S %>% 
  group_by(query, window.midpoint) %>%
  summarise(Count=n()) %>%
  ggplot(aes(x=window.midpoint, y=Count)) +
  #geom_bar(stat='identity') +
  geom_point(size=1, alpha=0.5) + 
  geom_line(size=0.5, alpha=0.25) +
  theme_bw() +
  theme.text.size +
  labs(x="Genome Position (T. pallidum SS14; 71 bp windows)", y="Genome Hit Count\n(100% kmer identity)")


p.COBS661K_window.search.23S_zoom <- p.COBS661K_window.search.23S_all + facet_zoom(ylim = c(0, 1000), xlim=c(234750, 236000), zoom.size = 1.25, split=F, shrink=F)

p.COBS661K_window.search.23S_zoom

```
\
\
Ok, identify regions with abnormal hit counts
```{r}
COBS661K_window.search.23S.summary <- COBS661K_window.search.23S %>% 
  group_by(query, window.midpoint) %>%
  summarise(Count=n()) %>%
  ungroup() %>%
  mutate(mean=mean(Count), c.median=median(Count)) %>%
  mutate(count.abnormal=ifelse(Count<=c.median*0.25,"v.low",
                               ifelse(Count<=c.median*0.5,"lower",
                                      ifelse(Count<=c.median*0.95, "low",
                                             ifelse(Count>=c.median*4,"v.high",
                                                    ifelse(Count>=c.median*2,"higher",
                                                           ifelse(Count>=c.median*1.05,"high","normal")))))))
COBS661K_window.search.23S.summary


COBS661K_window.search.23S.high.windows.not.massive <- COBS661K_window.search.23S %>% filter( query %in% 
                                         (COBS661K_window.search.23S.summary %>% filter(count.abnormal %in% c("high", "higher")) %>% select(query) %>% pull()))

p.COBS661K_window.search.23S.high.windows <- ggplot(COBS661K_window.search.23S.high.windows.not.massive, aes(y=query, fill=major_species)) +
  geom_barh(stat='count',position='stack') + 
  theme_bw() + theme.text.size + theme(legend.key.size=unit(0.65,"line")) +
  labs(y="Oversampled windows", x="Genome Hit Counts and Species", fill="Species")
p.COBS661K_window.search.23S.high.windows

COBS661K_window.search.23S.low.windows <- COBS661K_window.search.23S %>% filter( query %in% 
                                         (COBS661K_window.search.23S.summary %>% filter(count.abnormal %in% c("low", "lower", "v.low")) %>% select(query) %>% pull()))
ggplot(COBS661K_window.search.23S.low.windows, aes(y=query, fill=major_species)) +
  geom_barh(stat='count',position='stack') + 
  theme_bw() + theme.text.size + theme(legend.key.size=unit(0.65,"line"))


COBS661K_window.search.23S %>% 
  filter(query %in% (COBS661K_window.search.23S.summary %>% filter(count.abnormal=="normal") %>% select(query) %>% pull())) %>% 
  ggplot(aes(y=query, fill=major_species)) +
  geom_barh(stat='count',position='stack') + 
  theme_bw() + theme.text.size + theme(legend.key.size=unit(0.65,"line"))
  
COBS661K_window.search.23S %>% 
  filter(query %in% (COBS661K_window.search.23S.summary %>% filter(count.abnormal=="v.high") %>% select(query) %>% pull())) %>% 
  ggplot(aes(y=query, fill=major_species)) +
  geom_barh(stat='count',position='stack') + 
  theme_bw() + theme.text.size + theme(legend.key.size=unit(0.55,"line")) + 
  theme(legend.position='none')
```
\
Combine plots
```{r}
p.23S_profiling_screen <- plot_grid(p.COBS661K_window.search.23S_zoom, p.COBS661K_window.search.23S.high.windows, nrow=2, labels = c("A - Conservation of T. pallidum 23S region accross Bacterial Kingdom", "B - Species classification of over represented regions"), label_size = 11, scale=0.95, vjust=1, hjust=0)

p.23S_profiling_screen 

#ggsave(plot=p.23S_profiling_screen, paste0(Ancillary_Figures_directory,"p.23S_profiling_screen.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=180, height=200, device='pdf', dpi=400) 
```

\
Ok, define a set of windows that will need to be masked
```{r}

COBS661K_window.search.23S.abnormal_windows <- COBS661K_window.search.23S %>% 
  filter(query %in% (COBS661K_window.search.23S.summary %>% filter(count.abnormal!="normal") %>% select(query) %>% pull())) %>%
  select(query, window.start, window.end, window.midpoint) %>%
  distinct()

COBS661K_window.search.23S.abnormal_windows
```
\
Find continuous runs of windows
```{r}

# For each abnormal window, what is the genomic distance to the window before and after (i.e. are they adjacent or not)?
COBS661K_window.search.23S.abnormal_windows$genomic.dist.to.next <- sapply(1:nrow(COBS661K_window.search.23S.abnormal_windows), function(x) COBS661K_window.search.23S.abnormal_windows$window.midpoint[x+1]-COBS661K_window.search.23S.abnormal_windows$window.midpoint[x])

COBS661K_window.search.23S.abnormal_windows$genomic.dist.to.before <- sapply(1:nrow(COBS661K_window.search.23S.abnormal_windows), function(x) COBS661K_window.search.23S.abnormal_windows$window.midpoint[x]-COBS661K_window.search.23S.abnormal_windows$window.midpoint[x-1])

# Filter to only keep the transition points
COBS661K_window.search.23S.abnormal_windows.filt <- COBS661K_window.search.23S.abnormal_windows %>% filter(genomic.dist.to.before>10)

# Now group into intersecting interval groups
COBS661K_window.search.23S.abnormal_windows$interval <- findInterval(COBS661K_window.search.23S.abnormal_windows$window.midpoint, COBS661K_window.search.23S.abnormal_windows.filt$window.midpoint)
COBS661K_window.search.23S.abnormal_windows$interval2 <- paste0("Int_",COBS661K_window.search.23S.abnormal_windows$interval)


COBS661K_window.search.23S.abnormal_windows.interval.groups <- COBS661K_window.search.23S.abnormal_windows %>% 
  group_by(interval) %>%
  summarise(start.pos=min(window.start)-5, end.pos=max(window.end)+5,
            start.pos.gene=start.pos - 233094, end.pos.gene=end.pos - 233094, 
            chromosome="TPANIC_RS01130")
  
COBS661K_window.search.23S.abnormal_windows.interval.groups


COBS661K_window.search.23S.abnormal_windows.interval.groups.bed <- COBS661K_window.search.23S.abnormal_windows.interval.groups %>% select(chromosome, start.pos.gene, end.pos.gene)

COBS661K_window.search.23S.abnormal_windows.interval.groups.bed <- rbind(COBS661K_window.search.23S.abnormal_windows.interval.groups.bed, c("TPANIC_RS01130",1,1750))


#write.table(COBS661K_window.search.23S.abnormal_windows.interval.groups.bed, file="/Users/mb29/Treponema/Treponema_References/23S_alleles/23S_o1_Nich_variable-site-masking.20220624.bed", sep = "\t", col.names=F, row.names=F, quote=F)

```

\
Read in primer designs (primal scheme has generated two amplicons, but only really need one)
```{r}
primalscheme.design.23S <- read.delim(primalscheme.design.23S.file, sep="\t", header=T)
primalscheme.design.23S$amplicon <- paste0("23S_",gsub("\\_RIGHT","", gsub("\\_LEFT","", primalscheme.design.23S$name)))
primalscheme.design.23S$primer.side <- gsub("^.+\\_","", primalscheme.design.23S$name)

primalscheme.design.23S.amplicons <- primalscheme.design.23S %>% select(amplicon, primer.side, seq) %>%
  pivot_wider(values_from=seq, names_from=primer.side)


# validate with primer blast
#primer.blast.23s.output.all <- NULL 
#for (current in 1:nrow(primalscheme.design.23S.amplicons[,])){
#  print(paste0("(",current,") ", "searching against amplicon ", primalscheme.design.23S.amplicons$amplicon[current]))
#  primer.search.output1 <- parse_primer_hits(primer_search(primalscheme.design.23S.amplicons$LEFT[current], primalscheme.design.23S.amplicons$RIGHT[current], num_aligns=5000)$`1`)
#  primer.search.output1.taxon <- get_taxonomy(primer.search.output1$accession)
#  primer.search.output1 <- left_join(primer.search.output1, primer.search.output1.taxon, by="accession")
#  primer.search.output1 <- primer.search.output1 %>% select(c("accession", "product_length", "mismatch_forward", "mismatch_reverse", "forward_start", "forward_stop", "reverse_start", "reverse_stop", "product_start", "product_stop", "taxId", "subspecies", "superkingdom", "phylum", "class", "order", "family", "genus", "species"))
#  primer.search.output1$amplicon <- primalscheme.design.23S.amplicons$amplicon[current]
#  primer.blast.23s.output.all <- rbind(primer.blast.23s.output.all, primer.search.output1)
#}
#primer.blast.23s.output.all

#write.table(primer.blast.23s.output.all, file="/Users/mb29/Treponema/Treponema_References/23S_alleles/23S_o1_Nich_variable-site-masking.20220624.primerblast.searches.tsv", sep = "\t", col.names=T, row.names=F, quote=F)


###################################################
# Precalculated due to time
primer.blast.23s.output.all <- read.delim(primer.blast.23s.output.all.file, sep = "\t", comment.char = "", check.names = F, header=T)

primer.blast.23s.output.all

primer.blast.23s.output.all %>% group_by(amplicon,species) %>%
  summarise(count=n())

# Ok, so we have a single non-Tp hit in amplicon 2 - "Acinetobacter pittii". 
primer.blast.23s.output.all %>% filter(species=="Acinetobacter pittii")
# The "Acinetobacter pittii" amplicon is long with substantial mismatches - shouldn't be an issue. 

```

\
\
\
# Subsequent lab testing led to dropping some alleles - check the final scheme for sublineage coverage
```{r}
SS14.primer_binding.locations.iranges.good_regions <- SS14.primer_binding.locations.iranges.genehits.match %>% 
  filter(pcr.region %in% primalscheme.designs.SS14.binding_sites_full.table.good$amplicon) %>%
  arrange(pcr.region)

# What happens to the scheme if we can tweak the weaker ones, but lose the others?
length(SS14.primer_binding.locations.iranges.good_regions$region.cluster)
```


```{r}
p.bar.sublineage.coverage__using.final.scheme <- genomic.sites.retained.FSTpop.dataframe %>% 
  dplyr::filter(region.cluster %notin% SS14.primer_binding.locations.iranges.good_regions$region.cluster) %>%
  dplyr::group_by(population) %>%
  dplyr::summarise(count.sites=n()) %>% 
  dplyr::mutate(level=ifelse(population %in% c("Nichols","SS14"),"TPA_Lineage", ifelse(population %in% c("TPA", "TPE"), "Subspecies", "TP_Sublineage"))) %>%
  #dplyr::filter(level!="Subspecies") %>%
  dplyr::mutate(population= factor(population, levels=TP.FST_combined.cols$Population_sl)) %>%
  ggplot(aes(y=population, x=count.sites, fill=population)) +
  geom_barh(stat='identity', width=0.65) + 
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='top') + 
  scale_x_continuous(breaks=seq(0,20,1)) + 
  labs(x="Site Count", y="Genomic Sublineage", title=paste0("Genomic Sublineage Coverage (n=",length(SS14.primer_binding.locations.iranges.good_regions$region.cluster), " amplicons)\n- weakest amplicons lost, some optimisation"), fill="Genomic\nSublineage") +
  x.theme.axis.rotate.angle +
  scale_fill_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Classification", na.value = 'grey95') + theme(legend.position = 'none') +
  facet_grid(level~., scales = 'free_y', space='free_y') + y.facet.text.rotate

p.bar.sublineage.coverage__using.final.scheme


genomic.sites.retained.FSTpop.dataframe %>% filter(population=="sublin-1")
genomic.sites.retained.FSTpop.dataframe %>% filter(region.cluster=="RC195")

primalscheme.designs.SS14.binding_sites_full.table.good
```
\
So some of our lab validation means that discriminatory sites for key sublineages (particularly in TPA SS14) are lost
\
However, this only considers the SNPs included in the original discriminatory scheme - there will be other SNPs within the amplicons that can impact this. 
\
\
\
#### Hypothetical reconstruction using defined sites:
\
extract variable sites contained in proposed amplicons
\
```{r}
# Make list of sites within hypothetical amplicons
candidate.amplicon.SNP.sites <- as.character(unlist(genomic.sites.retained.FSTpop.dataframe %>% 
  arrange(as.numeric(POS)) %>%
  select(POS) %>% distinct()))


# Extract sites (as ATGCN alleles) from VCF matrix
candidate.amplicon.SNP.alleles.spread <- TPAE.SNPsVCF.gtallele.f.spread[,c("Indiv",candidate.amplicon.SNP.sites)]

# Convert sites to single sequence
candidate.amplicon.SNP.seqs <- data.frame(Indiv=candidate.amplicon.SNP.alleles.spread$Indiv, seq.cat=sapply( 1:nrow(candidate.amplicon.SNP.alleles.spread), function(x) paste(as.character(candidate.amplicon.SNP.alleles.spread[x,c(2:ncol(candidate.amplicon.SNP.alleles.spread))]), collapse="")))

# make seqinr sequence alignment in R
candidate.amplicon.SNP.seqs.alignment <- seqinr::as.alignment(nb=nrow(candidate.amplicon.SNP.seqs), nam=candidate.amplicon.SNP.seqs$Indiv, seq=candidate.amplicon.SNP.seqs$seq.cat)

# convert to DNAbin
candidate.amplicon.SNP.seqs.alignment.dnabin <- as.DNAbin(candidate.amplicon.SNP.seqs.alignment)

# convert to distance matrix
candidate.amplicon.SNP.seqs.alignment.dist <- dist.dna(candidate.amplicon.SNP.seqs.alignment.dnabin, model = "TN93")

# Create file name for fasta output
#index.fasta.out.filename <- paste0("/Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/", "TPAE-selected-sites_n",ncol(candidate.amplicon.SNP.alleles.spread)-1,"sites.",format(Sys.Date(),"%Y%m%d"),".fas")

#for (current.sample in c(1:length(candidate.amplicon.SNP.seqs.alignment$nam))){
 # seqinr::write.fasta(names =candidate.amplicon.SNP.seqs.alignment$nam[current.sample], sequences = #candidate.amplicon.SNP.seqs.alignment$seq[current.sample], file.out = index.fasta.out.filename,open="a", as.string = T)
#}

```
\
Run IQtree on amplicon sequence alignment
`iqtree -s TPAE-selected-sites_n141sites.20220531.fas -m GTR -mem 1G`
\
\
iqtree -h
\
`iqtree -s /Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/TPAE-selected-sites_n141sites.20220531.fas -m GTR -mem 1G`
\
\
\
Read in tree
```{r}
candidate.amplicon.SNP.seqs.141.iqtree <- read.tree(candidate.amplicon.SNP.seqs.141.iqtree.file)
```
\
```{r}
AmpliSeq_candidate.amplicon.SNP.seqs.141.tree.gg <- ggtree(midpoint.root(candidate.amplicon.SNP.seqs.141.iqtree))
AmpliSeq_candidate.amplicon.SNP.seqs.141.tree.gg.interval <- max(AmpliSeq_candidate.amplicon.SNP.seqs.141.tree.gg$data$x)/15

AmpliSeq_candidate.amplicon.SNP.seqs.141.tree.gg.circ <- ggtree(midpoint.root(candidate.amplicon.SNP.seqs.141.iqtree), layout='fan', open.angle = 20, right=T, size=0.35)


gheatmap(AmpliSeq_candidate.amplicon.SNP.seqs.141.tree.gg, d.TPAE.pinecone.10.TPAE.sublineages, color=NULL,width=0.05,offset=(1*AmpliSeq_candidate.amplicon.SNP.seqs.141.tree.gg.interval), colnames_angle=45,colnames_offset_y=0.02, hjust=1,font.size=text.size.within-0.5) +
  scale_fill_manual(breaks=TPA.TPE.scheme.cols$TPA.TPE.sublineage, values=TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols, name="Sublineage",na.value = "grey95", guide = guide_legend(order=1, ncol=3)) +
  theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  new_scale_fill()


gheatmap(AmpliSeq_candidate.amplicon.SNP.seqs.141.tree.gg.circ, d.TPAE.pinecone.10.TPAE.sublineages, color=NULL,width=0.05,offset=(1*AmpliSeq_candidate.amplicon.SNP.seqs.141.tree.gg.interval), colnames_angle=45,colnames_offset_y=0.02, hjust=1,font.size=text.size.within-0.5) +
  scale_fill_manual(breaks=TPA.TPE.scheme.cols$TPA.TPE.sublineage, values=TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols, name="Sublineage",na.value = "grey95", guide = guide_legend(order=1, ncol=3)) +
  theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  new_scale_fill()

```

\
Can we compare this to the WGS derived tree? 
Let's make a tanglegram
```{r, fig.height=6, fig.width=8}
# Or do it without making ultrametric (i.e. keep tree shape - perhaps more useful here)
WGS.ML.tree.ult <- Ampliseq_design.ML.tree
candidate.amplicons.tree.ult <- midpoint.root(candidate.amplicon.SNP.seqs.141.iqtree)


# Attach sublineage metadata to each tree
WGS.ML.tree.ult.ggtree <- ggtree(WGS.ML.tree.ult)
WGS.ML.tree.ult.ggtree <- WGS.ML.tree.ult.ggtree %<+% data.frame(Sample_Name=TPAE.pinecone.10$Taxa, TPAE.pinecone=TPAE.pinecone.10$TPA.TPE.scheme, stringsAsFactors=F) + 
  #geom_tippoint(aes(color=Sublineage), size=1, alpha=0.5) + 
  geom_tippoint(aes(color=TPAE.pinecone), size=1, alpha=0.15) +
  scale_color_manual(breaks=TPA.TPE.scheme.cols$TPA.TPE.sublineage, values=TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols, name="Sublineage",na.value = "grey95", guide = guide_legend(order=1, ncol=3)) +
  theme.text.size +
  NULL

candidate.amplicons.tree.ult.ggtree <- ggtree(candidate.amplicons.tree.ult)
candidate.amplicons.tree.ult.ggtree <- candidate.amplicons.tree.ult.ggtree %<+% data.frame(Sample_Name=TPAE.pinecone.10$Taxa, TPAE.pinecone=TPAE.pinecone.10$TPA.TPE.scheme, stringsAsFactors=F) + 
  geom_tippoint(aes(color=TPAE.pinecone), size=1, alpha=0.25) +
  theme.text.size

# Convert each to dataframes
d1 <- fortify(WGS.ML.tree.ult)
d2 <- fortify(candidate.amplicons.tree.ult)
#d2 <- candidate.amplicons.tree.ult.ggtree$data


## reverse x-axis and set offset to make the tree in the right hand side of the first tree
d2$x <- max(d2$x)*2500 - d2$x*2500 + max(d1$x) + 200


# Prepare dataframe for second tree with tip point colors
d2.meta <- d2 %>% 
  filter(isTip==T) %>% 
  left_join(data.frame(Sample_Name=TPAE.pinecone.10$Taxa, TPAE.pinecone=TPAE.pinecone.10$TPA.TPE.scheme), by=c("label"="Sample_Name"))


# Create initial plot of paired trees
pp <- WGS.ML.tree.ult.ggtree + 
  #ggnewscale::new_scale_color() +
  geom_tree(data=d2) + 
  geom_point(data=d2.meta, aes(x, y, color=TPAE.pinecone), size=1, alpha=0.25) +
  ggnewscale::new_scale_fill() 


# calculate intersections between trees for plotting lines
dd <- bind_rows(d1, d2) %>% 
  filter(!is.na(label))
dd <- dd[dd$isTip==T,]

# add sublineage metadata for colors
dd <- plyr::join(dd, WGS.ML.tree.ult.ggtree$data[,c("label","TPAE.pinecone")], by='label',type='left')

# plot combined tree with intersection lines
tangle.lines.ggtree <- pp + geom_line(aes(x, y, group=label,color=TPAE.pinecone), data=dd,  alpha=0.33, size=0.5)


# add tree headers 
TP.tanglegram.labels <- data.frame(label.x = c(max(d2$x)*0.25, max(d2$x)*0.85), 
           label.y = c(max(d1$y)*0.75, max(d2$y)*0.75), 
           label.text = c("Full WGS\ntree", "Amplicon derived\ntree"))

tangle.lines.ggtree <- tangle.lines.ggtree + geom_text(data=TP.tanglegram.labels, aes(y=label.y, x=label.x, label=label.text)) +
  theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  scale_color_manual(breaks=TPA.TPE.scheme.cols$TPA.TPE.sublineage, values=TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols, name="Sublineage",na.value = "grey95", guide = guide_legend(order=1, ncol=3))

tangle.lines.ggtree
```

\
# Do the same for the lab-revised scheme (which is missing some sublineage discriminatory sites)
\
extract variable sites contained in revised amplicons (including both 'discriminatory' and 'other')
\
```{r}
# Make list of sites within hypothetical amplicons

# Create new IRanges object of trustworthy amplicons
SS14.insert.sites__goodregions.IRanges <- IRanges(start=primalscheme.designs.SS14.binding_sites_full.table.good$insert_pos_F, end=primalscheme.designs.SS14.binding_sites_full.table.good$insert_pos_R, names=primalscheme.designs.SS14.binding_sites_full.table.good$amplicon)
#SS14.insert.sites__goodregions.IRanges

# Make list of ALL sites within dataaset
candidate.amplicon.SNP.sites.IRanges <- IRanges(start=as.numeric(candidate.amplicon.SNP.sites), end=as.numeric(candidate.amplicon.SNP.sites), name=as.character(candidate.amplicon.SNP.sites))

# Use IRanges to find overlaps - what SNPs in the WGS data are within our amplicons?
candidate.amplicon.SNP.sites__IRanges_overlap_with_good_primers <- data.frame(IRanges::findOverlaps(candidate.amplicon.SNP.sites.IRanges, SS14.insert.sites__goodregions.IRanges, select="all"))


# Extract positions and amplicons from IRanges comparison object
# Amplicons
candidate.amplicon.SNP.sites__IRanges_overlap_with_good_primers$amplicons <- sapply(1:length(candidate.amplicon.SNP.sites__IRanges_overlap_with_good_primers$subjectHits), function(x) primalscheme.designs.SS14.binding_sites_full.table.good$amplicon[candidate.amplicon.SNP.sites__IRanges_overlap_with_good_primers$subjectHits[x]])

# SNP positions
candidate.amplicon.SNP.sites__IRanges_overlap_with_good_primers$SNP_Pos <- sapply(1:length(candidate.amplicon.SNP.sites__IRanges_overlap_with_good_primers$queryHits), function(x) candidate.amplicon.SNP.sites[candidate.amplicon.SNP.sites__IRanges_overlap_with_good_primers$queryHits[x]])

candidate.amplicon.SNP.sites__IRanges_overlap_with_good_primers

paste(length(unique(candidate.amplicon.SNP.sites__IRanges_overlap_with_good_primers$amplicons)), "Amplicons")
paste(length(unique(candidate.amplicon.SNP.sites__IRanges_overlap_with_good_primers$SNP_Pos)), "SNPs")

```

\
Write sequences out to fasta file for tree calculation
```{r}
# Extract sites (as ATGCN alleles) from VCF matrix
candidate.amplicon.SNP.alleles.spread.good_amplicons <- TPAE.SNPsVCF.gtallele.f.spread[,c("Indiv",candidate.amplicon.SNP.sites__IRanges_overlap_with_good_primers$SNP_Pos)]
candidate.amplicon.SNP.alleles.spread.good_amplicons

# Convert sites to single sequence
candidate.amplicon.SNP.good_amplicons.seqs <- data.frame(Indiv=candidate.amplicon.SNP.alleles.spread.good_amplicons$Indiv, seq.cat=sapply( 1:nrow(candidate.amplicon.SNP.alleles.spread.good_amplicons), function(x) paste(as.character(candidate.amplicon.SNP.alleles.spread.good_amplicons[x,c(2:ncol(candidate.amplicon.SNP.alleles.spread.good_amplicons))]), collapse="")))

# make seqinr sequence alignment in R
candidate.amplicon.SNP.seqs.good_amplicons_alignment <- seqinr::as.alignment(nb=nrow(candidate.amplicon.SNP.good_amplicons.seqs), nam=candidate.amplicon.SNP.good_amplicons.seqs$Indiv, seq=candidate.amplicon.SNP.good_amplicons.seqs$seq.cat)

# Create file name for fasta output
#candidate.amplicon.SNP.seqs.alignment.fasta.filename <- paste0("/Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/", "TPAE-selected-sites_n",ncol(candidate.amplicon.SNP.alleles.spread)-1,"sites__revised_amplicons.608dataset.",format(Sys.Date(),"%Y%m%d"),".fas")

print("/Users/mb29/Treponema/Expanded_Global_Sequencing/Analysis/TP_Discriminatory_sites_2021/Phylo/TPAE-selected-sites_n174sites__revised_amplicons.608dataset.20240528.fas")

#for (current.sample in c(1:length(candidate.amplicon.SNP.seqs.good_amplicons_alignment$nam))){
#  seqinr::write.fasta(names =candidate.amplicon.SNP.seqs.good_amplicons_alignment$nam[current.sample], sequences = #candidate.amplicon.SNP.seqs.good_amplicons_alignment$seq[current.sample], file.out = #candidate.amplicon.SNP.seqs.alignment.fasta.filename, open="a", as.string = T)
#}

```
\
Run iqtree on the alignment
`iqtree -s TPAE-selected-sites_n174sites__revised_amplicons.608dataset.20240528.fas -m GTR -mem 1G`

```{r}
revised_candidate.amplicon.SNP.seqs.alignment.tree <- midpoint.root(read.tree(revised_candidate.amplicon.SNP.seqs.alignment.tree.filename))

revised_candidate.amplicon.SNP.seqs.alignment.tree <- ape::drop.tip(revised_candidate.amplicon.SNP.seqs.alignment.tree, "NC_021508_1_1")

revised_candidate.amplicon.SNP.seqs.alignment.tree.gg <- ggtree(revised_candidate.amplicon.SNP.seqs.alignment.tree)
revised_candidate.amplicon.SNP.seqs.alignment.tree.gg.circ <- ggtree(midpoint.root(revised_candidate.amplicon.SNP.seqs.alignment.tree), layout='fan', open.angle = 20, right=T, size=0.35)



gheatmap(revised_candidate.amplicon.SNP.seqs.alignment.tree.gg, d.TPAE.pinecone.10.TPAE.sublineages, color=NULL,width=0.05,offset=(1*AmpliSeq_candidate.amplicon.SNP.seqs.141.tree.gg.interval), colnames_angle=45,colnames_offset_y=0.02, hjust=1,font.size=text.size.within-0.5) +
  scale_fill_manual(breaks=TPA.TPE.scheme.cols$TPA.TPE.sublineage, values=TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols, name="Sublineage",na.value = "grey95", guide = guide_legend(order=1, ncol=3)) +
  theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  new_scale_fill()


gheatmap(revised_candidate.amplicon.SNP.seqs.alignment.tree.gg.circ, d.TPAE.pinecone.10.TPAE.sublineages, color=NULL,width=0.05,offset=(1*AmpliSeq_candidate.amplicon.SNP.seqs.141.tree.gg.interval), colnames_angle=45,colnames_offset_y=0.02, hjust=1,font.size=text.size.within-0.5) +
  scale_fill_manual(breaks=TPA.TPE.scheme.cols$TPA.TPE.sublineage, values=TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols, name="Sublineage",na.value = "grey95", guide = guide_legend(order=1, ncol=3)) +
  theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  new_scale_fill()
```
\
\
It's a bit messy to code these tanglegrams. Can we turn this into a function?
```{r}
plot_tanglegram <- function(mytree1, mytree2, mymetadata, colorscheme=TPA.TPE.scheme.cols, scale_difference=2000, centre_separation=200, pointsize=1, left_label_offset=0.15, right_label_offset=0.9){
  # Extract color variable name (1)
  colvar1.name <- colnames(mymetadata)[2]
  # Prepare color scheme
  colorscheme.temp <- colorscheme
  colnames(colorscheme.temp) <- c("variable","color")
  
  # Prepare trees and append metadata
  mytree1.gg <- ggtree(mytree1, size=0.4)
  mytree1.gg <- mytree1.gg %<+% mymetadata +
    geom_tippoint(aes_string(color=colvar1.name), size=pointsize, alpha=0.15) +
    theme.text.size  
  
  mytree2.gg <- ggtree(mytree2, size=0.4)
  mytree2.gg <- mytree2.gg %<+% mymetadata + 
    # Note that tippoints won't display for the second tree using geom_tippoint - need to do a workaround using geom_point
    #geom_tippoint(aes_string(color=colvar1.name), size=pointsize, alpha=0.15) + 
    theme.text.size  
  
  # Convert each to dataframes
  mytree1.d <- fortify(mytree1)
  mytree2.d <- fortify(mytree2)
  
  # reverse x-axis and set offset to make the tree on the right hand side of the first tree
  # this includes a scaling variable to adjust right-hand tree, since some trees may be very flat
  mytree2.d$x <- max(mytree2.d$x)*scale_difference - mytree2.d$x*scale_difference + max(mytree1.d$x) + centre_separation
  
  # Prepare dataframe for second tree with tip point colors
  mytree2.meta <- mytree2.d %>% 
    filter(isTip==T) %>% 
    left_join(mymetadata, by=c("label"="Sample_Name"))

  # Create initial plot of paired trees
  mytrees.pp <- mytree1.gg + 
    #ggnewscale::new_scale_color() +
    geom_tree(data=mytree2.d) + 
    geom_point(data=mytree2.meta, aes_string("x", "y", color=colvar1.name), size=pointsize, alpha=0.25) +
    ggnewscale::new_scale_fill() 
  
  # calculate intersections between trees for plotting lines
  mytrees.dd <- bind_rows(mytree1.d, mytree2.d) %>% 
    filter(!is.na(label))
  mytrees.dd <- mytrees.dd[mytrees.dd$isTip==T,]
  
  # add sublineage metadata for colors
  col.variable.name <- colnames(mytree1.gg$data[,10])
  mytrees.dd <- left_join(mytrees.dd, mytree1.gg$data[,c("label",col.variable.name)], by='label')
  
  # plot combined tree with intersection lines
  mytrees_tangle.lines.ggtree <- mytrees.pp + geom_line(aes_string("x", "y", group="label",color=col.variable.name), data=mytrees.dd,  alpha=0.5, size=0.25)
  
  # add tree headers 
  mytrees_tanglegram.labels <- data.frame(label.x = c(max(mytree2.d$x)*left_label_offset, max(mytree2.d$x)*right_label_offset), 
                                          label.y = c(max(mytree1.d$y)*0.85, max(mytree2.d$y)*0.85), 
                                          label.text = c("Full WGS\ntree", "Amplicon\nderived\ntree"))
  
  mytrees_tangle.lines.ggtree <- mytrees_tangle.lines.ggtree + geom_text(data=mytrees_tanglegram.labels, aes(y=label.y, x=label.x, label=label.text)) +
    theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
    scale_color_manual(breaks=colorscheme.temp$variable, values=colorscheme.temp$color, name="Sublineage",na.value = "grey95", guide = guide_legend(order=1))
  
  return(mytrees_tangle.lines.ggtree)
}

```

\
Now plot
```{r, fig.width=8, fig.height=8}
p.WGS_dataset_vs_56amplicon_finalsites_tanglegram <- plot_tanglegram(WGS.ML.tree.ult, revised_candidate.amplicon.SNP.seqs.alignment.tree, data.frame(Sample_Name=TPAE.pinecone.10$Taxa, TPAE.pinecone=TPAE.pinecone.10$TPA.TPE.scheme, stringsAsFactors=F), TPA.TPE.scheme.cols, scale_difference = 1750, centre_separation = 250)

p.WGS_dataset_vs_56amplicon_finalsites_tanglegram <- p.WGS_dataset_vs_56amplicon_finalsites_tanglegram + theme(legend.position = c(0.875, 0.6))

p.WGS_dataset_vs_56amplicon_finalsites_tanglegram

#ggsave(plot=p.WGS_dataset_vs_56amplicon_finalsites_tanglegram, paste0(Figures_directory,"Figure3__Tanglegram_WGS-vs-59amplicons.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=200, height=200, device='pdf', dpi=400)

```
\
\
What about extracting and comparing subtrees?
```{r}
# TPA only
p.WGS_dataset_vs_56amplicon_finalsites_tanglegram__TPA.only <- plot_tanglegram(keep.tip(WGS.ML.tree.ult, filter(TPA.meta1, Cleaned_fastq_id %in% WGS.ML.tree.ult$tip.label, Species=="TPA") %>% pull(Cleaned_fastq_id) ), 
                keep.tip(revised_candidate.amplicon.SNP.seqs.alignment.tree, filter(TPA.meta1, Cleaned_fastq_id %in% WGS.ML.tree.ult$tip.label, Species=="TPA") %>% pull(Cleaned_fastq_id) ), 
                data.frame(Sample_Name=TPAE.pinecone.10$Taxa, TPAE.pinecone=TPAE.pinecone.10$TPA.TPE.scheme, stringsAsFactors=F), TPA.TPE.scheme.cols, scale_difference = 1000, centre_separation = 10) +
  ggtitle("TPA only")

p.WGS_dataset_vs_56amplicon_finalsites_tanglegram__TPA.only


# TPE only
p.WGS_dataset_vs_56amplicon_finalsites_tanglegram__TPE.only <- plot_tanglegram(keep.tip(WGS.ML.tree.ult, filter(TPA.meta1, Cleaned_fastq_id %in% WGS.ML.tree.ult$tip.label, Species=="TPE") %>% pull(Cleaned_fastq_id) ), 
                keep.tip(revised_candidate.amplicon.SNP.seqs.alignment.tree, filter(TPA.meta1, Cleaned_fastq_id %in% WGS.ML.tree.ult$tip.label, Species=="TPE") %>% pull(Cleaned_fastq_id) ), 
                data.frame(Sample_Name=TPAE.pinecone.10$Taxa, TPAE.pinecone=TPAE.pinecone.10$TPA.TPE.scheme, stringsAsFactors=F), TPA.TPE.scheme.cols, scale_difference = 250, centre_separation = 5, pointsize=2) +
  ggtitle("TPE only")

p.WGS_dataset_vs_56amplicon_finalsites_tanglegram__TPE.only



# SS14 TPA only
plot_tanglegram(keep.tip(WGS.ML.tree.ult, filter(TPA.meta1, Cleaned_fastq_id %in% WGS.ML.tree.ult$tip.label, Species=="TPA", TPA_Lineage=="SS14") %>% pull(Cleaned_fastq_id) ), 
                keep.tip(revised_candidate.amplicon.SNP.seqs.alignment.tree, filter(TPA.meta1, Cleaned_fastq_id %in% WGS.ML.tree.ult$tip.label, Species=="TPA", TPA_Lineage=="SS14") %>% pull(Cleaned_fastq_id) ), 
                data.frame(Sample_Name=TPAE.pinecone.10$Taxa, TPAE.pinecone=TPAE.pinecone.10$TPA.TPE.scheme, stringsAsFactors=F), TPA.TPE.scheme.cols, scale_difference = 1000, centre_separation = 5) +
  ggtitle("SS14 TPA only")

# Nichols TPA only
plot_tanglegram(keep.tip(WGS.ML.tree.ult, filter(TPA.meta1, Cleaned_fastq_id %in% WGS.ML.tree.ult$tip.label, Species=="TPA", TPA_Lineage=="Nichols") %>% pull(Cleaned_fastq_id) ), 
                keep.tip(revised_candidate.amplicon.SNP.seqs.alignment.tree, filter(TPA.meta1, Cleaned_fastq_id %in% WGS.ML.tree.ult$tip.label, Species=="TPA", TPA_Lineage=="Nichols") %>% pull(Cleaned_fastq_id) ), 
                data.frame(Sample_Name=TPAE.pinecone.10$Taxa, TPAE.pinecone=TPAE.pinecone.10$TPA.TPE.scheme, stringsAsFactors=F), TPA.TPE.scheme.cols, scale_difference = 500, centre_separation = 10, pointsize=2) +
  ggtitle("Nichols TPA only")
```
\
\
## Quantitative analysis of performance for Ampliseq placement
\
First, compare distance between the two matrices (i.e. Mantel test)
```{r, eval=F}
#revised_candidate.amplicon.SNP.seqs.alignment.tree$tip.label
#Ampliseq_design.ML.tree$tip.label

#revised_candidate.amplicon.SNP.seqs.alignment.tree$tip.label[revised_candidate.amplicon.SNP.seqs.alignment.tree$tip.label %notin% Ampliseq_design.ML.tree$tip.label]
#Ampliseq_design.ML.tree$tip.label[revised_candidate.amplicon.SNP.seqs.alignment.tree$tip.label %notin% Ampliseq_design.ML.tree$tip.label]
#Ampliseq_design.ML.tree$tip.label[Ampliseq_design.ML.tree$tip.label %notin% revised_candidate.amplicon.SNP.seqs.alignment.tree$tip.label]
#Ampliseq_design.ML.tree$tip.label[revised_candidate.amplicon.SNP.seqs.alignment.tree$tip.label %notin% Ampliseq_design.ML.tree$tip.label]

revised_candidate.amplicon.SNP.seqs.alignment.dist <- cophenetic.phylo(drop.tip(revised_candidate.amplicon.SNP.seqs.alignment.tree, c("31818_2#31.Treponema.ds2500000-reads", "NC_021508.1_1")))
Ampliseq_design.ML.dist <- cophenetic.phylo(drop.tip(Ampliseq_design.ML.tree, c("31818_2#31.Treponema.ds2500000-reads", "NC_021508.1_1")))


```
\
Mantel stats on distance matrix (very slow to run)
```
Mantel statistic based on Spearman's rank correlation rho 

Call:
mantel(xdis = revised_candidate.amplicon.SNP.seqs.alignment.dist,      ydis = Ampliseq_design.ML.dist, method = "spearman", permutations = 10000,      na.rm = F, parallel = 4) 

Mantel statistic r: 0.3631 
      Significance: 9.999e-05 

Upper quantiles of permutations (null model):
   90%    95%  97.5%    99% 
0.0352 0.0462 0.0557 0.0675 
Permutation: free
Number of permutations: 10000
```
\
```{r}
options(scipen = 999)
mantel_P_value <- 9.999e-05
```
\
\
\
###Treespace Analysis
Can we compare the similarity of these trees (Kendall-Colijn or Robinson's fauld distance)? Given the design here (expected differences in branch lengths, highly clonal expansions, some uncertainty in phylogenetic placement even in WGS trees), that may not be optimal. However Treespace also offers a method to compare tree clustering (i.e. known groups) within a reference tree against a set of other trees. 
\

```{r}
c(revised_candidate.amplicon.SNP.seqs.alignment.tree, Ampliseq_design.ML.tree)

# make trees contain the same tip labels
PhyloSeq_Amplicon_tree.fixed.tre <- drop.tip(revised_candidate.amplicon.SNP.seqs.alignment.tree, c("31818_2#31.Treponema.ds2500000-reads", "NC_021508.1_1"))

PhyloSeq_WGS_tree.fixed.tre <- drop.tip(Ampliseq_design.ML.tree, c("31818_2#31.Treponema.ds2500000-reads", "NC_021508.1_1"))

# Run basic treespace
treeDist(PhyloSeq_WGS_tree.fixed.tre, PhyloSeq_Amplicon_tree.fixed.tre)

# format into columns so can be made compatible with later stuff
#treeDist_amplicon.vs.WGS.df <- data.frame(row=1, col=2, value=treeDist(PhyloSeq_WGS_tree.fixed.tre, PhyloSeq_Amplicon_tree.fixed.tre), method="Amplicon Tree")

# or to change to Robinson Foulds
Treespace.amplicon_vs_WGS <- treespace(c(PhyloSeq_WGS_tree.fixed.tre, PhyloSeq_Amplicon_tree.fixed.tre, PhyloSeq_Amplicon_tree.fixed.tre), nf=3, method="treeVec")

treeDist_amplicon.vs.WGS.df <- melt(as.matrix(Treespace.amplicon_vs_WGS$D), varnames = c("row", "col")) %>% 
  filter(row==1) %>%
  filter(col!=1) %>%
  filter(col!=3) %>%
  mutate(method="Amplicon Tree")

# Identical trees (0)
treeDist_WGS.vs.WGS.df <- data.frame(row=1, col=1, value=treeDist(PhyloSeq_WGS_tree.fixed.tre, PhyloSeq_WGS_tree.fixed.tre), method="Identical WGS trees")
```
\
Ok, Treespace provides a quantitative 'score' that is hard to contextualise. 
What if we try to compare the output from the true comparison with:
 - Tip randomised trees (likely to be very poor correlation)
 - Bootstrapped WGS trees (likely to be highly correlated)
 
 
\
First, sort out the dataset. We can't include 'singleton' sublineages, because (i) the Amplicon scheme wasn't designed to detect them, and (ii) the label 'singleton' is polyphyletic in the tree, so will prevent the analyses from working. 
\

```{r}
# Try adding sublineage data to enable the more recent 'group distance comparisons' in treespace
treespace.metadata.df <- data.frame(Sample_Name=TPAE.pinecone.10$Taxa, TPAE.pinecone=TPAE.pinecone.10$TPA.TPE.scheme, stringsAsFactors=F) %>% filter(Sample_Name %in% PhyloSeq_WGS_tree.fixed.tre$tip.label)
treespace.metadata.df <- treespace.metadata.df %>% select(TPAE.pinecone, Sample_Name)

treespace.metadata.df <- treespace.metadata.df %>%
   arrange(match(Sample_Name, PhyloSeq_WGS_tree.fixed.tre$tip.label))


# Double check that we have metadata for all samples
filter(data.frame(tip.label=PhyloSeq_WGS_tree.fixed.tre$tip.label), tip.label %notin% treespace.metadata.df$Sample_Name)
filter(data.frame(tip.label=PhyloSeq_Amplicon_tree.fixed.tre$tip.label), tip.label %notin% treespace.metadata.df$Sample_Name)

# more checking
filter(data.frame(tip.label=PhyloSeq_WGS_tree.fixed.tre$tip.label), tip.label %in% "22931_6#11.Treponema.ds2500000-reads")
filter(data.frame(tip.label=PhyloSeq_Amplicon_tree.fixed.tre$tip.label), tip.label %in% "22931_6#11.Treponema.ds2500000-reads")

treespace.metadata.df %>% filter(Sample_Name %in% "22931_6#11.Treponema.ds2500000-reads") 

# First ensure the exact same tips are present
PhyloSeq_Amplicon_tree.fixed.tre <- ape::keep.tip(PhyloSeq_Amplicon_tree.fixed.tre, PhyloSeq_WGS_tree.fixed.tre$tip.label)

# Maybe remove all singletons?
PhyloSeq_WGS_tree.fixed.tre.noSing <- ape::keep.tip(PhyloSeq_WGS_tree.fixed.tre, filter(treespace.metadata.df, TPAE.pinecone!="Singleton") %>% pull(Sample_Name))

PhyloSeq_Amplicon_tree.fixed.tre.noSing <- ape::keep.tip(PhyloSeq_Amplicon_tree.fixed.tre, filter(treespace.metadata.df, TPAE.pinecone!="Singleton") %>% pull(Sample_Name))

treespace.metadata.df.noSing <- filter(treespace.metadata.df, TPAE.pinecone!="Singleton")
 
df <- (cbind(treespace.metadata.df.noSing$TPAE.pinecone, treespace.metadata.df.noSing$Sample_Name))
df
``` 

 
\
Do tip randomisation first - make 100 tip randomised versions of the original WGS tree
```{r}
total.resamples <- 100
all.relabelled.trees <- c(rtree(20)) # create with random start tree to force into a multiphylo object
current.bootstrap <- 0
repeat {
  current.bootstrap <- current.bootstrap + 1
  relabeled.tip.tre.tmp <- PhyloSeq_WGS_tree.fixed.tre.noSing
  # Need to remove 'singleton sublineages'
  relabeled.tip.tre.tmp$tip.label <- sample(PhyloSeq_WGS_tree.fixed.tre.noSing$tip.label)
  all.relabelled.trees <- c(all.relabelled.trees,c(relabeled.tip.tre.tmp),recursive=T)
  if (current.bootstrap >= total.resamples){
    break
  }
}
all.relabelled.trees <- all.relabelled.trees[c(2:(total.resamples+1))] # remove random start tree

all.relabelled.trees
```

\
\
Now try and do bootstrapping (from original iqtree run)
```{r}
# Specify non-parametric bootstraps of original iqtree tree (generated using `-b 100`)
# Ampliseq_design.ML.tree.bootstraps.file

# Read in tree file
Ampliseq_design.ML.tree.bootstraps <- read.tree(Ampliseq_design.ML.tree.bootstraps.file)

# drop tips to make dataset the same
Ampliseq_design.ML.tree.bootstraps <- ape::drop.tip(Ampliseq_design.ML.tree.bootstraps, c("31818_2#31.Treponema.ds2500000-reads", "NC_021508.1_1"))

# Remove 'singleton' sublineages
Ampliseq_design.ML.tree.bootstraps.noSing <- ape::keep.tip(Ampliseq_design.ML.tree.bootstraps, filter(treespace.metadata.df, TPAE.pinecone!="Singleton") %>% pull(Sample_Name))

# Run Treespace  
Ampliseq_design.ML.tree.bootstraps_treespace <- treespace(c(PhyloSeq_WGS_tree.fixed.tre, Ampliseq_design.ML.tree.bootstraps), nf=3, method="RF")


Ampliseq_design.ML.tree.bootstraps_treespace.df <- melt(as.matrix(Ampliseq_design.ML.tree.bootstraps_treespace$D), varnames = c("row", "col")) %>% 
  filter(row==1) %>%
  filter(col!=1) %>%
  mutate(method="Tree Bootstraps")

```


\
Now do treeConcordance analysis
```{r}
# Ok - treeConcordance allows comparison between a 'collapsed category' tree and a sample tree
# We could create a category tree by subsampling tips from each sublineage
# A robust way to approach this would be to make multiple subsampled trees for this purpose, and use it to bootstrap the method

# Alternatively, it would make more sense to use the makeCollapsedTree function in the treespace package.

collapsed_WGS.tree <- makeCollapsedTree(PhyloSeq_WGS_tree.fixed.tre.noSing, filter(treespace.metadata.df, TPAE.pinecone!="Singleton", !is.na(TPAE.pinecone)), warnings = TRUE)

collapsed_WGS.tree.ggtree <- ggtree(collapsed_WGS.tree, ladderize = F)

p.collapsed_WGS.sublineages.tree.ggtree <- collapsed_WGS.tree.ggtree %<+% 
  data.frame(Sample_Name=TPA.TPE.scheme.cols$TPA.TPE.sublineage, TPAE.pinecone=TPA.TPE.scheme.cols$TPA.TPE.sublineage, stringsAsFactors=F) + 
  geom_tippoint(aes(color=TPAE.pinecone), size=2, alpha=0.8) +
  scale_color_manual(breaks=TPA.TPE.scheme.cols$TPA.TPE.sublineage, values=TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols, name="Sublineage",na.value = "grey95", guide = guide_legend(order=1, ncol=3)) +
  theme.text.size + theme(legend.position = 'none') +
  geom_tiplab(size=text.size.within) + 
  xlim_tree(max(collapsed_WGS.tree.ggtree$data$x)*1.1)

p.collapsed_WGS.sublineages.tree.ggtree
```
\
\
Can we make a collapsed tree version of the Amplicon tree?
```{r}
collapsed_AmpliconPCR.tree <- makeCollapsedTree(PhyloSeq_Amplicon_tree.fixed.tre.noSing, filter(treespace.metadata.df, TPAE.pinecone!="Singleton", !is.na(TPAE.pinecone)), warnings = TRUE)

collapsed_AmpliconPCR.tree.ggtree <- ggtree(collapsed_AmpliconPCR.tree, ladderize = F)

p.collapsed_AmpliconPCR.sublineages.tree.ggtree <- collapsed_AmpliconPCR.tree.ggtree %<+% 
  data.frame(Sample_Name=TPA.TPE.scheme.cols$TPA.TPE.sublineage, TPAE.pinecone=TPA.TPE.scheme.cols$TPA.TPE.sublineage, stringsAsFactors=F) + 
  geom_tippoint(aes(color=TPAE.pinecone), size=2, alpha=0.8) +
  scale_color_manual(breaks=TPA.TPE.scheme.cols$TPA.TPE.sublineage, values=TPA.TPE.scheme.cols$TPA.TPE.sublineage.cols, name="Sublineage",na.value = "grey95", guide = guide_legend(order=1, ncol=3)) +
  theme.text.size + theme(legend.position = 'none') +
  geom_tiplab(size=text.size.within) #+ 
  #xlim_tree(max(collapsed_WGS.tree.ggtree$data$x)*1.1)

p.collapsed_AmpliconPCR.sublineages.tree.ggtree
```

\
Make tanglegram of collapsed trees
```{r}
#data.frame(Sample_Name=TPAE.pinecone.10$Taxa, TPAE.pinecone=TPAE.pinecone.10$TPA.TPE.scheme)
data.frame(Sample_Name=TPA.TPE.scheme.cols$TPA.TPE.sublineage, TPAE.pinecone=TPA.TPE.scheme.cols$TPA.TPE.sublineage, stringsAsFactors=F)

collapsed_WGS.tree
collapsed_AmpliconPCR.tree

plot_tanglegram(collapsed_WGS.tree, collapsed_AmpliconPCR.tree, data.frame(Sample_Name=TPA.TPE.scheme.cols$TPA.TPE.sublineage, TPAE.pinecone=TPA.TPE.scheme.cols$TPA.TPE.sublineage, stringsAsFactors=F), colorscheme = TPA.TPE.scheme.cols, scale_difference = 500, centre_separation = 50, pointsize = 2.5, right_label_offset = 1) + theme(legend.position = 'bottom')

```

\
Run tree concordance analyses between different datasets
```{r, eval=F}
###########
# Compare collapsed tree with full WGS tree
WGS_tree_vs_collapsedtree__treeConcordance <- treeConcordance(collapsed_WGS.tree, PhyloSeq_WGS_tree.fixed.tre.noSing, filter(treespace.metadata.df, TPAE.pinecone!="Singleton", !is.na(TPAE.pinecone)))

###########
# Compare collapsed tree with full amplicon tree
Amplicon_tree_vs_collapsedtree__treeConcordance <- treeConcordance(collapsed_WGS.tree, PhyloSeq_Amplicon_tree.fixed.tre.noSing, filter(treespace.metadata.df, TPAE.pinecone!="Singleton", !is.na(TPAE.pinecone)))

###########
# Compare collapsed tree with WGS bootstrapped trees
WGS_bootstraps_vs_collapsedtree__treeConcordance <- NULL
for (current.tree in 1:100){
  treeConcordance.temp <- treeConcordance(collapsed_WGS.tree, Ampliseq_design.ML.tree.bootstraps.noSing[[current.tree]], filter(treespace.metadata.df, TPAE.pinecone!="Singleton", !is.na(TPAE.pinecone)))
  WGS_bootstraps_vs_collapsedtree__treeConcordance <- c(treeConcordance.temp, WGS_bootstraps_vs_collapsedtree__treeConcordance)
}

###########
# Compare collapsed tree with Tip randomised trees
WGS_tiprandomised_vs_collapsedtree__treeConcordance <- NULL
for (current.tree in 1:100){
  treeConcordance.temp <- treeConcordance(collapsed_WGS.tree, all.relabelled.trees[[current.tree]], filter(treespace.metadata.df, TPAE.pinecone!="Singleton", !is.na(TPAE.pinecone)))
  WGS_tiprandomised_vs_collapsedtree__treeConcordance <- c(treeConcordance.temp, WGS_tiprandomised_vs_collapsedtree__treeConcordance)
}

Combined_treeConcordance.df <- data.frame(treeConcordance=c(WGS_tree_vs_collapsedtree__treeConcordance,Amplicon_tree_vs_collapsedtree__treeConcordance,WGS_bootstraps_vs_collapsedtree__treeConcordance,WGS_tiprandomised_vs_collapsedtree__treeConcordance), Tree=c("WGS_tree", "Amplicon_Tree", rep("WGS_Bootstraps", 100), rep("Tip_Randomised", 100)))

Combined_treeConcordance.df

#write.csv(Combined_treeConcordance.df, file="/Users/mb29/Treponema/Treponema_Discriminatory_Sites__MinION/Analysis/AmpliSeq_design_dataset-plots_06-2024/Combined_treeConcordance_20240924.csv", row.names = F, quote=F)
```


\
```{r}
# Precalculated concordance analysis
# Combined_treeConcordance.df2.file
Combined_treeConcordance.df2 <- read.csv(Combined_treeConcordance.df2.file)

Combined_treeConcordance.df2 %>%
  group_by(Tree) %>% 
  mutate(Tree=factor(Tree, levels=c(c("WGS_tree", "Amplicon_Tree", "WGS_Bootstraps","Tip_Randomised")))) %>%
  summarise(median=median(treeConcordance))

p.Combined_treeConcordance.df2_sinaplot <- Combined_treeConcordance.df2 %>%
  group_by(Tree) %>% mutate(median=median(treeConcordance)) %>%
  ungroup() %>%
  mutate(Tree=factor(Tree, levels=c(c("WGS_tree", "Amplicon_Tree", "WGS_Bootstraps","Tip_Randomised")))) %>%
  ggplot(aes(x=Tree, y=treeConcordance)) +
  geom_quasirandom(alpha=0.4, size=2) +
  theme_bw() + theme.text.size + x.theme.axis.rotate.angle +
  labs(y="Tree Concordance", x="Tree Dataset") +
  stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median, geom = "crossbar", width = 0.75, size=0.25, color='blue')
p.Combined_treeConcordance.df2_sinaplot

```
\
Plot together with tree
```{r}
p.treeConcordance_collapsedTree_combi <- plot_grid(p.collapsed_WGS.sublineages.tree.ggtree, p.Combined_treeConcordance.df2_sinaplot, ncol=2, label_size = 11, labels = c("A - Collapsed WGS tree", "B - Tree Concordance"), vjust=1.05, scale=0.95)

p.treeConcordance_collapsedTree_combi

#ggsave(plot=p.treeConcordance_collapsedTree_combi, paste0(Figures_directory,"SuppFig11__TreeConcordance.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=180, height=140, device='pdf', dpi=400)
```

\
\
What about distinguishing sublineage membership?
\
Want to know if samples with identical amplicon profiles can be part of different WGS sublineages (hopefully they are not).
```{r}
# extract pairwise cophenetic distance matrix from tree
#PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist <- ape::cophenetic.phylo(PhyloSeq_Amplicon_tree.fixed.tre.noSing)


# Or do it directly from the SNP alignment using pairsnp (which would mean things are scaled by SNPs rather than distance)

# candidate.amplicon.SNP.seqs.alignment.fasta.filename
candidate.amplicon.SNP.seqs.alignment.sparse.data <- import_fasta_sparse(candidate.amplicon.SNP.seqs.alignment.fasta.filename)
candidate.amplicon.SNP.seqs.alignment.distances <- snp_dist(candidate.amplicon.SNP.seqs.alignment.sparse.data)

PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt <- data.frame(Taxa1=row.names(candidate.amplicon.SNP.seqs.alignment.distances),candidate.amplicon.SNP.seqs.alignment.distances)  
colnames(PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt) <- c("Taxa1",row.names(PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt))

PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt <- PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt %>% 
  pivot_longer(-Taxa1, names_to="Taxa2", values_to = "Distance.Phylo") 

# plot distribution of distances
PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt %>%
  ggplot(aes(Distance.Phylo)) + geom_histogram() + theme_bw()
```

{# plot distribution of distances
PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt %>%
  ggplot(aes(Distance.Phylo)) + geom_histogram()
```{r}
#################
# Add sublineage metadata
PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta <- treespace.metadata.df %>%
  rename_with(~ paste0(.x, ".T1",  recycle0 = TRUE)) %>%
  right_join(PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt, by=c("Sample_Name.T1"="Taxa1"))

PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta <- treespace.metadata.df %>% 
  rename_with(~ paste0(.x, ".T2",  recycle0 = TRUE)) %>%
  right_join(PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta, by=c("Sample_Name.T2"="Taxa2")) %>% 
  ungroup()

PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta <- PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta %>% select(Sample_Name.T1, Sample_Name.T2, Distance.Phylo, TPAE.pinecone.T1, TPAE.pinecone.T2)

#################
# Setup comparisons and exclude same sample links
PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta <- PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta %>% 
  mutate(same.sample=ifelse(Sample_Name.T1==Sample_Name.T2, "Same", "Different")) %>%
  mutate(same.sublineage = ifelse(TPAE.pinecone.T1==TPAE.pinecone.T2, "Same","Different"))

#PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta

PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta$taxa_combination <- sapply(1:nrow(PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta), function (x) paste0(sort(c(as.character(PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta$Sample_Name.T1[x]),as.character(PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta$Sample_Name.T2[x]))),collapse="---"))

#################
# Restrict to 'identical' amplicon clusters (i.e. want to know if 'identical' samples are exclusive to one WGS sublineage - which they should be if the scheme is 100% accurate in it's delineation)
PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta_d0 <- PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta %>%
  filter(same.sample=="Different") %>%
  filter(Distance.Phylo==0) %>%
  distinct(taxa_combination, .keep_all = T)

PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta_d0
```
\


```{r}
set.seed(123456789)
PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta_d0_4net <- PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta_d0 %>% select(Sample_Name.T1, Sample_Name.T2, Distance.Phylo)

Amplicon_dataset.0d.network <- network(PhyloSeq_Amplicon_tree.fixed.tre.noSing__dist.melt__meta_d0_4net, matrix.type = "edgelist", ignore.eval = FALSE, directed = F, multiple = F)

# Make network into a ggnetwork object
Amplicon_dataset.0d.network.gg <- ggnetwork(Amplicon_dataset.0d.network, layout = "fruchtermanreingold")
Amplicon_dataset.0d.network.gg$Taxa1 <- Amplicon_dataset.0d.network.gg$vertex.names


# extract SNP clusters from network using iGraph
Amplicon_dataset.0d.network.ig <- asIgraph(Amplicon_dataset.0d.network)
Amplicon_dataset.0d.network.components <- data.frame(Taxa1=network.vertex.names(Amplicon_dataset.0d.network), vertex.no=as.vector(V(Amplicon_dataset.0d.network.ig)), cluster=igraph::components(Amplicon_dataset.0d.network.ig)$membership)
Amplicon_dataset.0d.network.components$SNPcluster <- paste0("SC",Amplicon_dataset.0d.network.components$cluster)

# merge metadata back in
Amplicon_dataset.0d.network.gg <- treespace.metadata.df %>% 
  full_join(Amplicon_dataset.0d.network.gg, by=c("Sample_Name"="Taxa1")) %>%
  left_join(select(Amplicon_dataset.0d.network.components, c(Taxa1, SNPcluster)), by=c("Sample_Name"="Taxa1")) %>%
  left_join(select(TP.FST_combined.cols, -Color), by=c("TPAE.pinecone"="Classification"))
  

p.ampliseq_final__identical.snp.network <- ggplot(Amplicon_dataset.0d.network.gg, aes(x = x, y = y, xend = xend, yend = yend)) + 
  geom_edges(alpha=0.50, curvature = 0.05, color="grey50") +
  geom_nodes(aes(color = Population_sl), size=3, alpha=0.5) +
  theme_bw() + theme.text.size + x.theme.axis.rotate.angle +
  scale_color_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl)

p.ampliseq_final__identical.snp.network

```
So some sublineages (defined at the WGS level) are not fully distinguishable from others using the final 59-amplicon scheme. Need to examine this further.

- Make a network of identical SNP profiles in amplicon scheme, and compare to WGS sublineage assignment.
\
```{r, fig.width=12, fig.height=4}
Amplicon_dataset.0d.network.gg__distinct.SNPclusters <- Amplicon_dataset.0d.network.gg %>% 
  distinct(Sample_Name, TPAE.pinecone, SNPcluster) %>% 
  filter(!is.na(TPAE.pinecone)) %>%
  mutate(SNPcluster=ifelse(is.na(SNPcluster),"single_snp",SNPcluster)) %>% 
  arrange(desc(SNPcluster)) %>%
  mutate(num= paste0("singleton_",1:n())) %>%
  mutate(network.cluster=ifelse(SNPcluster=="single_snp",num, SNPcluster)) %>%
  select(-num) %>% 
  arrange(SNPcluster) %>%
  left_join(select(TP.FST_combined.cols, -Color), by=c("TPAE.pinecone"="Classification")) %>%
  mutate(subspecies=ifelse(grepl("sublin-TPE", Population_sl),"TPE", ifelse(grepl("sublin-Singleton",Population_sl),"Singleton", ifelse(grepl("sublin-", Population_sl), "TPA","uk"))))


Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sumstats <- Amplicon_dataset.0d.network.gg__distinct.SNPclusters %>%
  group_by(network.cluster) %>%
  mutate(total.net.cluster=n()) %>%
  ungroup() %>%
  group_by(network.cluster,Population_sl) %>%
  mutate(count=n(), net.fract.pop=count/total.net.cluster) %>%
  dplyr::arrange(desc(TPAE.pinecone), .by_group=T) %>% 
  distinct(network.cluster, Population_sl, count, net.fract.pop, total.net.cluster) %>%
  dplyr::mutate(fraction=count/total.net.cluster, cum_fract=cumsum(fraction), cum_fract.mid = cum_fract-(fraction/2)) %>% 
  filter(!is.na(Population_sl))


Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sumstats <- Amplicon_dataset.0d.network.gg__distinct.SNPclusters %>% 
  dplyr::group_by(network.cluster,Population_sl) %>%
  dplyr::summarise(Count=n()) %>%
  dplyr::mutate(total.region=sum(Count)) %>%
  dplyr::arrange(desc(Population_sl), .by_group=T) %>%
  dplyr::mutate(fraction=Count/total.region, cum_fract=cumsum(fraction), cum_fract.mid = cum_fract-(fraction/2))

p.Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sublineage.composition.bar <- Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sumstats %>% 
  ggplot(aes(x=network.cluster, y=Count, fill=Population_sl)) +
  geom_bar(stat='identity', width=0.65, position='fill', alpha=0.8) +
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  x.theme.axis.rotate.angle +
  scale_fill_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl) +
  labs(x="Identical SNP cluster", y="Proportion from each sublineage", fill="Sublineage") +
  geom_text(aes(x=network.cluster, y=cum_fract.mid, label=Count), size=text.size.within-0.5)
  #facet_grid(.~subspecies, scale='free_x', space='free_x') +
  #scale_y_log10()
  NULL
p.Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sublineage.composition.bar

p.Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sublineage.composition.bar_mixeds <- Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sumstats %>% 
  filter(fraction!=1) %>%
  ggplot(aes(x=network.cluster, y=Count, fill=Population_sl)) +
  geom_bar(stat='identity', width=0.65, position='fill') +
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  x.theme.axis.rotate.angle +
  scale_fill_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl) +
  labs(x="Identical SNP cluster", y="Proportion from each sublineage", fill="Sublineage") +
  geom_text(aes(x=network.cluster, y=cum_fract.mid, label=Count), size=text.size.within)
  
p.Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sublineage.composition.bar_mixeds


plot_grid(p.Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sublineage.composition.bar, p.Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sublineage.composition.bar_mixeds, ncol=1)
```
\
\
Maybe also show a plot of the WGS tree that indicates which sublineages are not fully delineated using the final PCR scheme
```{r}
collapsed_WGS.tree
p.collapsed_WGS.sublineages.tree.ggtree +
  geom_strip("1", "5", barsize=1, color='red', offset.text=.1) +
  geom_strip("2", "2", barsize=1, color='red', offset.text=.1) +
  #geom_strip('10', '11', '12', barsize=1, color='red', label="merged", offset.text=.1) +
  NULL

p.collapsed_WGS.sublineages.tree.ggtree$data$label

```

\
Can we use the collapsed WGS tree to illustrate the single linkage clusters within the amplicon dataset?
```{r, fig.width=8, fig.height=6}
Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sumstats %>% 
  ungroup() %>%
  filter(Population_sl!="sublin-Singleton") %>%
  group_by(network.cluster) %>%
  mutate(sublin.per.ident.cluster=n()) %>%
  select(Population_sl, network.cluster, sublin.per.ident.cluster)
  

Amplicon_dataset.0d.network.gg__distinct.SNPcluster__treemeta <- Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sumstats %>% 
  ungroup() %>%
  left_join(TP.FST_combined.cols, by="Population_sl") %>%
  filter(Population_sl!="sublin-Singleton") %>% 
  mutate(network.num=as.numeric(gsub("SC","",network.cluster))) %>%
  mutate(network.num2=as.numeric(gsub("singleton_","", gsub("SC","",network.cluster)))) %>%
  mutate(network.num2=ifelse(grepl("singleton", network.cluster), network.num2 + nrow(distinct(filter(Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sumstats, grepl("SC",network.cluster)))), network.num2)) %>%
  select(Classification, network.cluster, network.num2, Population_sl)

  
p.collapsed_WGS.sublineages.tree_with_identical.clusters <- facet_plot(p.collapsed_WGS.sublineages.tree.ggtree + scale_color_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Classification, guide = 'none') + geom_rootedge(rootedge = 10), panel = "Identical Amplicon Profile", data = Amplicon_dataset.0d.network.gg__distinct.SNPcluster__treemeta, geom = geom_tile, aes(x = network.num2, fill = Population_sl), color='grey5', alpha=0.8) + 
  theme.text.size + theme_bw() +
  scale_y_continuous(minor_breaks=seq(1, length(collapsed_WGS.tree$tip.label), by = 1), expand=c(0.01,0.01)) +
  scale_x_continuous(breaks=seq(1,max(Amplicon_dataset.0d.network.gg__distinct.SNPcluster__treemeta$network.num2), by = 10), minor_breaks=seq(1,max(Amplicon_dataset.0d.network.gg__distinct.SNPcluster__treemeta$network.num2), by = 1), expand=c(0.01,0.01)) +
  x.theme.strip.labs + y.theme.strip +
  scale_fill_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl) +
  theme(legend.key.size = unit(0.55,"line"),legend.position='right') +
  labs(fill="Sublineage")
p.collapsed_WGS.sublineages.tree_with_identical.clusters

```
\
Plot tree with breakdown
```{r, fig.width=10, fig.height=8}
p.collapsed_WGS.sublineages.tree_with_identical.clusters_w.bar_combi <- plot_grid(p.collapsed_WGS.sublineages.tree_with_identical.clusters + theme(legend.position='none'), p.Amplicon_dataset.0d.network.gg__distinct.SNPcluster__sublineage.composition.bar + guides(fill = guide_legend(ncol=2)), ncol=1, rel_heights = c(3,2), label_size = 11, labels=c("A - Whole genome phylogeny v.s. Identical amplicon profiles", "B - Sublineage identity within identical amplicon profiles"), vjust=1.1, scale=0.95)
p.collapsed_WGS.sublineages.tree_with_identical.clusters_w.bar_combi

#ggsave(plot=p.collapsed_WGS.sublineages.tree_with_identical.clusters_w.bar_combi, paste0(Figures_directory,"SuppFig10__Amplicon_Sublin-discrimination_tree.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=240, height=200, device='pdf', dpi=400) 

```
\
\
\
\

# Now look at how well this scheme reconstructs other datasets and population structures
\
First look at UK dataset from Beale et al, 2023 (Lancet Microbe paper)
```{r}
# Amplicon primer sequence locations
# primalscheme.designs.SS14.binding_sites_full.table__subset.good_amplicons

# Illumina WGS multi-sample VCF of UK syphilis genomes from Lancet Microbe paper
# UK_Illumina_data.vcf.file


# Import data from VCF (already processed - can use import of tables later on to speed this up)
UK_Illumina_data.vcf <- read.vcfR(UK_Illumina_data.vcf.file, verbose = FALSE )

UK_Illumina_data.vcf.tidy <- vcfR2tidy(UK_Illumina_data.vcf, single_frame = T, format_fields = c("GT"))


#Extract elements we want (can take a long time)
UK_Illumina_data.df <- UK_Illumina_data.vcf.tidy$dat %>% select(CHROM,POS,ID,REF,ALT,gt_GT, gt_GT_alleles,Indiv,FILTER,QUAL) %>%
  mutate(gt_GT= ifelse(gt_GT_alleles==".","0",gt_GT), gt_GT_alleles=ifelse(gt_GT_alleles==".", REF, gt_GT_alleles))

UK_Illumina_data.df

# Remove big datasets from R environment (for memory saving)
rm(UK_Illumina_data.vcf.tidy)
rm(UK_Illumina_data.vcf)
```
\
Infer variants
```{r}
UK_Illumina_data.df <- UK_Illumina_data.df %>% mutate(gt_GT_simplify= ifelse(gt_GT=="0/1","0",
                                ifelse(gt_GT=="1","1", 
                                       ifelse(gt_GT=="1/1","1",
                                              ifelse(gt_GT=="2","2",
                                                     ifelse(gt_GT=="2/2","2",
                                                            ifelse(gt_GT=="3","3",
                                                                   ifelse(gt_GT=="3/3","3",
                                                                          ifelse(gt_GT=="0/0","0", 
                                                                                 ifelse(gt_GT=="0","0", 
                                                                                    ifelse(gt_GT_alleles==".","0", NA)))))))))))

UK_Illumina_data.df
```
\
\
Lookup SNPs within range of trustworty amplicons
```{r}
# Create new IRanges object of trustworthy amplicons
SS14.insert.sites__goodregions.IRanges <- IRanges(start=primalscheme.designs.SS14.binding_sites_full.table__subset.good_amplicons$insert_pos_F, end=primalscheme.designs.SS14.binding_sites_full.table__subset.good_amplicons$insert_pos_R, names=primalscheme.designs.SS14.binding_sites_full.table__subset.good_amplicons$amplicon)
#SS14.insert.sites__goodregions.IRanges

#primalscheme.designs.SS14.binding_sites_full.table__subset.good_amplicons

# Extract unique SNPs in UK dataset, and create IRanges object
UK_Illumina_data.unique_SNPsites <- unique(UK_Illumina_data.df$POS)
UK_Illumina_data.unique_SNPsites.IRanges <- IRanges(start=UK_Illumina_data.unique_SNPsites, end=UK_Illumina_data.unique_SNPsites, name=as.character(UK_Illumina_data.unique_SNPsites))

# Use IRanges to find overlaps - what SNPs in the WGS data are within our amplicons?
UK_Illumina_data.unique_SNPsites__IRanges_overlap_with_good_primers <- data.frame(IRanges::findOverlaps(UK_Illumina_data.unique_SNPsites.IRanges, SS14.insert.sites__goodregions.IRanges, select="all"))
#UK_Illumina_data.unique_SNPsites__IRanges_overlap_with_good_primers


# Extract positions and amplicons from IRanges comparison object
# Amplicons
UK_Illumina_data.unique_SNPsites__IRanges_overlap_with_good_primers$amplicons <- sapply(1:length(UK_Illumina_data.unique_SNPsites__IRanges_overlap_with_good_primers$subjectHits), function(x) primalscheme.designs.SS14.binding_sites_full.table__subset.good_amplicons$amplicon[UK_Illumina_data.unique_SNPsites__IRanges_overlap_with_good_primers$subjectHits[x]])

# SNP positions
UK_Illumina_data.unique_SNPsites__IRanges_overlap_with_good_primers$SNP_Pos <- sapply(1:length(UK_Illumina_data.unique_SNPsites__IRanges_overlap_with_good_primers$queryHits), function(x) UK_Illumina_data.unique_SNPsites[UK_Illumina_data.unique_SNPsites__IRanges_overlap_with_good_primers$queryHits[x]])

UK_Illumina_data.unique_SNPsites__IRanges_overlap_with_good_primers

paste(length(unique(UK_Illumina_data.unique_SNPsites__IRanges_overlap_with_good_primers$amplicons)), "Amplicons")
paste(length(unique(UK_Illumina_data.unique_SNPsites__IRanges_overlap_with_good_primers$SNP_Pos)), "SNPs")
```

\
\
Now subset variant positions in dataframe to only include those we would expect in the amplicons
```{r}
UK_Illumina_data.__AmpliSeq_sim.df <- UK_Illumina_data.df %>% 
  filter(POS %in% UK_Illumina_data.unique_SNPsites__IRanges_overlap_with_good_primers$SNP_Pos)
UK_Illumina_data.__AmpliSeq_sim.df

UK_Illumina_data.__AmpliSeq_sim.df.spread <- UK_Illumina_data.__AmpliSeq_sim.df %>%
  select(POS, Indiv, gt_GT_alleles) %>%
  distinct() %>%
  pivot_wider(names_from="POS", values_from = "gt_GT_alleles")

UK_Illumina_data.__AmpliSeq_sim.seqs <- UK_Illumina_data.__AmpliSeq_sim.df.spread %>% 
  unite("sequence", sep = "", -Indiv, remove = TRUE)
UK_Illumina_data.__AmpliSeq_sim.seqs

UK_Illumina_data.__AmpliSeq_sim.seqs <- UK_Illumina_data.__AmpliSeq_sim.seqs %>% filter(Indiv != "NC_021508_1_1")

# Create file name for fasta output
UK_Illumina_data.__AmpliSeq_sim.seqs.filename <- paste0("/Users/mb29/Treponema/Treponema_Discriminatory_Sites__MinION/simulate_AmpliSeq_for_UK__05-2024/", "UK_Illumina_data.__AmpliSeq_sim.seqs_variants_",ncol(UK_Illumina_data.__AmpliSeq_sim.df.spread)-1,"sites.",format(Sys.Date(),"%Y%m%d"),".fas")

#for (current.sample in c(1:length(UK_Illumina_data.__AmpliSeq_sim.seqs$Indiv))){
#  seqinr::write.fasta(names =UK_Illumina_data.__AmpliSeq_sim.seqs$Indiv[current.sample], sequences = #UK_Illumina_data.__AmpliSeq_sim.seqs$sequence[current.sample], file.out = #UK_Illumina_data.__AmpliSeq_sim.seqs.filename, open="a", as.string = T)
#}

```
\
\
run iqtree
`/data/pam/team216/mb29/scratch/Treponema/TP_Discriminatory_sites_2021/simulate_AmpliSeq_for_UK__05-2024`
`perl -pe 's/\*/N/g' UK_Illumina_data.__AmpliSeq_sim.seqs_variants_42sites.20240503.fas > UK_Illumina_data.__AmpliSeq_sim.seqs_variants_42sites.20240503.fix.fas`

`bsub.py 2 iqtree_ampliseq-UK-sim.log iqtree -s UK_Illumina_data.__AmpliSeq_sim.seqs_variants_42sites.20240503.fas -m GTR -mem 1G`
\
\
Read in tree
```{r}
# UK_Illumina_data.__AmpliSeq_sim.pyjar_tree.filename

UK_Illumina_data.__AmpliSeq_sim.pyjar.phylo <- read.tree(UK_Illumina_data.__AmpliSeq_sim.pyjar_tree.filename)
ggtree(UK_Illumina_data.__AmpliSeq_sim.pyjar.phylo)
```
\

Read in grapetree plot (in Beale 2023, snp-scaled trees were used as input to grapetree to produce snp-scaled minimum spanning trees). This will allow replication of the minimum spanning trees from Beale 2023 using the amplicon data. 
```{r}
# Amplicon derived minimum spanning tree plot: UK_Illumina_data.__AmpliSeq_sim.pyjar.grapetree.file

# WGS derived minimum spanning tree plot: UK_Illumina_WGS_grapetree.file

p.UK_Illumina_data.__AmpliSeq_sim.pyjar.grapetree <- ggdraw() + draw_image(UK_Illumina_data.__AmpliSeq_sim.pyjar.grapetree.file)

p.UK_Illumina_WGS_grapetree <- ggdraw() + draw_image(UK_Illumina_WGS_grapetree.file)



p.UK_Illumina_data.__AmpliSeq_sim.pyjar.grapetree
p.UK_Illumina_WGS_grapetree

p.UK_Illumina_data.__AmpliSeq_vs_WGS__grapetree_combi <- plot_grid(p.UK_Illumina_WGS_grapetree, p.UK_Illumina_data.__AmpliSeq_sim.pyjar.grapetree, ncol=1, labels = c("A - UK WGS network", "B - UK AmpliSeq network (inferred)"), label_size = 11, scale=0.95)

p.UK_Illumina_data.__AmpliSeq_vs_WGS__grapetree_combi

#ggsave(plot=p.UK_Illumina_data.__AmpliSeq_vs_WGS__grapetree_combi, paste0(Figures_directory,"SuppFig12__UK-pop-structures.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=200, height=200, device='pdf', dpi=400)

```
\
\
\
\

# Lab based analysis - assessing the PCR/sequencing performance
Look at lab performance - South African clinical dataset
\
First look at coverage of amplicons in the multiplex
```{r}
# Coverage file from South African amplicon data: TP20230502SA.region.depth.file

TP20230502SA.region.depth <- read.csv(TP20230502SA.region.depth.file, sep="\t")

TP20230502SA.region.depth <- TP20230502SA.region.depth %>%
  mutate(MinION_Sequencing_Run=gsub("TP_Discriminatory_","",gsub("\\_barcode.+$","",Sample))) %>%
  mutate(barcode=gsub("TP_Discriminatory_","",gsub("\\.filt","",TP20230502SA.region.depth$Sample)))

# Metadata for lab samples from South African study: TP_SA.lab.metadata.file
TP_SA.lab.metadata <- readxl::read_excel(TP_SA.lab.metadata.file)
TP_SA.lab.metadata
```
\
Merge and plot
```{r, fig.height=8, fig.width=8}
TP20230502SA.region.depth.meta <- TP20230502SA.region.depth %>% 
  left_join(TP_SA.lab.metadata, by=c("barcode"="ONT_barcode","MinION_Sequencing_Run")) %>%
  select(barcode, MinION_Sequencing_Run, Region, StartPos, EndPos, Length, Tp47_qPCR_Ct, Missing_Sites, Median_Cov, Mean_Cov, Min_Cov, cov1x.perc, cov5x.perc, cov20x.perc, bam.mapped.filt.readcount) %>%
  filter(Region %notin% c("23S_scheme2_a2","23S_scheme2_a1","23S_scheme1_a2")) %>%
  mutate(Region=ifelse(Region=="23S_scheme1_a1", "rRNA_23S", Region))

TP20230502SA.region.depth.meta
```
\
Identify samples and regions that perform well or poorly in general
```{r}
# Identify poorly performing samples (systematic issue)
TP20230502SA.region.depth.good.samples.tab <- TP20230502SA.region.depth.meta %>% 
  group_by(barcode) %>%
  summarise(mean.cov=mean(Mean_Cov), quant.5pc=quantile(Mean_Cov, 0.05)) %>%
  mutate(poor.performing.samples=ifelse(mean.cov<50, "Poor","ok")) 
TP20230502SA.region.depth.good.samples.tab

TP20230502SA.region.depth.good.samples.tab %>% 
  group_by(poor.performing.samples) %>% summarise(count=n())

TP20230502SA.region.depth.good.samples.list2 <- TP20230502SA.region.depth.good.samples.tab  %>%
  filter(poor.performing.samples!="Poor")%>% 
  pull(barcode)

# Filter amplicons (exclude samples that do poorly in general first)
TP20230502SA.region.depth.consistent.amplicons.tab <- TP20230502SA.region.depth.meta %>% 
  filter(barcode %in% TP20230502SA.region.depth.good.samples.list2) %>%
  group_by(Region) %>%
  summarise(mean.cov=mean(Mean_Cov),median.cov=median(Median_Cov), min.cov=min(Mean_Cov), max.cov=max(Mean_Cov), quant.5pc=quantile(Mean_Cov, 0.05), quant.95pc=quantile(Mean_Cov, 0.95), quant.10pc=quantile(Mean_Cov, 0.10), quant.90pc=quantile(Mean_Cov, 0.90)) %>% 
  filter(quant.10pc>25)
# filters amplicons that are below the 10th percentile for mean amplicon coverage
TP20230502SA.region.depth.consistent.amplicons.tab

TP20230502SA.region.depth.consistent.amplicons.list <- TP20230502SA.region.depth.consistent.amplicons.tab %>% pull(Region)
```

\
Check range of qPCR values
```{r}
TP20230502SA.region.depth.meta %>%
  distinct(barcode, MinION_Sequencing_Run, Tp47_qPCR_Ct) %>%
  summarise(mean.Ct=mean(Tp47_qPCR_Ct), max.Ct=max(Tp47_qPCR_Ct), min.Ct=min(Tp47_qPCR_Ct))
```

\
Plot
```{r, fig.height=8, fig.width=8}
p.SA.meancov_vs_Ct.facet.scatter <- TP20230502SA.region.depth.meta %>%
  mutate(`<20X`=ifelse(Mean_Cov<25, "yes","no")) %>%
  mutate(good.amplicon=ifelse(Region %in% TP20230502SA.region.depth.consistent.amplicons.list, "yes","no")) %>%
  mutate(Region.alt = gsub("all","region", Region)) %>%
  #ggplot(aes(Tp47_qPCR_Ct, Mean_Cov, color=`<25X`)) +
  ggplot(aes(Tp47_qPCR_Ct, Mean_Cov, color=good.amplicon)) +
    geom_point(alpha=0.25, size=1) +
    scale_y_log10() +
    facet_wrap(vars(Region.alt)) +
    theme_bw() +
    theme.text.size + x.theme.axis.rotate.angle +
    geom_hline(yintercept=25, color='blue', linewidth=0.5, alpha=0.8) +
    labs(y="Mean Coverage (X) per amplicon", x="qPCR Ct", title = "Mean sequencing coverage by sample input per amplicon") +
    scale_color_manual(values=c("grey5", "red"), breaks=c("yes","no")) +
  theme(legend.position='bottom')
  
p.SA.meancov_vs_Ct.facet.scatter <- rasterize(p.SA.meancov_vs_Ct.facet.scatter, layers='Point', dpi=400)

p.SA.meancov_vs_Ct.facet.scatter

#ggsave(plot=p.SA.meancov_vs_Ct.facet.scatter, paste0(Figures_directory,"SuppFig9__PCR-amplicon-performance.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=180, height=180, device='pdf', dpi=400)
```
\
Also look at per-sample performance
```{r, fig.width=8, fig.height=8}
p.SA.meancov_vs_Ct__per_sample.facet.scatter <- TP20230502SA.region.depth.meta %>%
  mutate(`<20X`=ifelse(Mean_Cov<20, "yes","no")) %>%
  mutate(good.amplicon=ifelse(Region %in% TP20230502SA.region.depth.consistent.amplicons.list, "yes","no")) %>%
  mutate(Region.alt = gsub("all","region", Region)) %>%
  arrange(Tp47_qPCR_Ct) %>%
  mutate(barcode=factor(barcode, levels=unique(barcode))) %>%
  #ggplot(aes(barcode, Mean_Cov, color=`<20X`)) +
  ggplot(aes(barcode, Mean_Cov, color=good.amplicon)) +
  #geom_violin(alpha=0.25, size=0.5, inherit.aes = F, aes(barcode, Mean_Cov)) +
  geom_quasirandom(alpha=0.25, size=1) +
  scale_y_log10() +
  #facet_wrap(vars(barcode)) +
  theme_bw() +
  x.theme.axis.rotate.angle +
  theme.text.size + 
  #theme(text = element_text(size = 9)) + 
  labs(y="Mean Coverage (X) per amplicon", x="Sample") +
  scale_color_manual(values=c("grey5", "red"), breaks=c("yes","no")) +
  theme(legend.position='bottom') +
  geom_hline(yintercept=20, color='blue', linewidth=0.5, alpha=0.8)
p.SA.meancov_vs_Ct__per_sample.facet.scatter <- rasterize(p.SA.meancov_vs_Ct__per_sample.facet.scatter, layers='Point', dpi=400)
#p.SA.meancov_vs_Ct__per_sample.facet.scatter

p.SA.qPCR_values.scatter <- TP20230502SA.region.depth.meta %>%
  distinct(barcode, Tp47_qPCR_Ct) %>%
  arrange(Tp47_qPCR_Ct) %>%
  mutate(barcode=factor(barcode, levels=unique(barcode))) %>%
  ggplot(aes(x=barcode, y=Tp47_qPCR_Ct)) +
  geom_point(size=0.5) +
  theme_bw() +
  x.theme.axis.rotate.angle +
  theme.text.size
#p.SA.qPCR_values.scatter

p.SA.meancov_vs_Sample_vs_Ct__per_sample.combi <- plot_grid(p.SA.qPCR_values.scatter + x.theme.strip.labs, p.SA.meancov_vs_Ct__per_sample.facet.scatter, ncol=1, rel_heights = c(1,4), axis="lr", align="v", scale=0.90)

p.SA.meancov_vs_Sample_vs_Ct__per_sample.combi

#ggsave(plot=p.SA.meancov_vs_Sample_vs_Ct__per_sample.combi, paste0(Figures_directory,"SuppFig8__PCR-sample-performance.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=250, height=220, device='pdf', dpi=400)
```
\
Look at mapped readcounts
```{r}
TP20230502SA.region.depth.meta %>% 
  distinct(barcode, bam.mapped.filt.readcount) %>%
  ggplot(aes(y=barcode, x=bam.mapped.filt.readcount)) +
  geom_barh(stat='identity')
  
TP20230502SA.region.depth.meta %>% 
  distinct(barcode, MinION_Sequencing_Run, bam.mapped.filt.readcount) %>%
  group_by(MinION_Sequencing_Run) %>%
  summarise(all.run.readcounts=sum(bam.mapped.filt.readcount))
  
TP20230502SA.region.depth.meta %>% 
  distinct(barcode, MinION_Sequencing_Run, bam.mapped.filt.readcount) %>%
  summarise(max.reads=max(bam.mapped.filt.readcount), min.reads=min(bam.mapped.filt.readcount), median.reads=median(bam.mapped.filt.readcount))

TP20230502SA.region.depth.meta %>%
  summarise(median.cov=median(Median_Cov), median.min.cov=min(Median_Cov), median.max.cov=max(Median_Cov))
```
\
Based on this filtering, make a final plot of sublineage support in the scheme (incorporating data from earlier stages)
```{r, fig.width=8, fig.height=6}
# Recalculate support for each sublineage using the total discriminatory site list
FST.support_sublineage.all_sites <- FST.sublin.combined.TPAE.sig %>% 
  distinct(population, POS) %>%
  dplyr::group_by(population) %>%
  dplyr::summarise(count=n()) %>%
  dplyr::mutate(sublineage=(gsub("sublin-","",population))) %>%
  dplyr::arrange(sublineage) %>%
  dplyr::mutate(sublineage=factor(sublineage,levels=sort(sublineage))) %>%
  dplyr::mutate(level=ifelse(sublineage %in% c("Nichols","SS14"),"TPA_Lineage", ifelse(sublineage %in% c("TPA", "TPE"), "Subspecies", "TP_Sublineage"))) %>%
  mutate(Dataset.Long="All Discriminatory Sites", Dataset.Short="All Sites")

# Recalculate support for each sublineage using the hierarchically selected regions
FST.support_sublineage.retained_sites <- genomic.sites.retained.FSTpop %>% 
  filter(region.cluster %in% hierarchical.FST.sites.to.keep) %>%
  distinct(population, POS) %>%
  dplyr::group_by(population) %>%
  dplyr::summarise(count=n()) %>%
  dplyr::mutate(sublineage=(gsub("sublin-","",population))) %>%
  dplyr::arrange(sublineage) %>%
  dplyr::mutate(sublineage=factor(sublineage,levels=sort(sublineage))) %>%
  dplyr::mutate(level=ifelse(sublineage %in% c("Nichols","SS14"),"TPA_Lineage", ifelse(sublineage %in% c("TPA", "TPE"), "Subspecies", "TP_Sublineage"))) %>%
  mutate(Dataset.Long="Sites in regions selected by algorithm", Dataset.Short="Selected Regions")

# Recalculate support for each sublineage using the regions in the final optimised PCR
FST.support_sublineage.final_PCR_sites <- genomic.sites.retained.FSTpop.dataframe %>% 
    dplyr::filter(region.cluster %notin% SS14.primer_binding.locations.iranges.good_regions$region.cluster) %>%
    dplyr::group_by(population) %>%
    dplyr::summarise(count=n()) %>%
    dplyr::mutate(sublineage=(gsub("sublin-","",population))) %>%
    dplyr::arrange(sublineage) %>%
    dplyr::mutate(sublineage=factor(sublineage,levels=sort(sublineage))) %>%
    dplyr::mutate(level=ifelse(sublineage %in% c("Nichols","SS14"),"TPA_Lineage", ifelse(sublineage %in% c("TPA", "TPE"), "Subspecies", "TP_Sublineage"))) %>% 
  mutate(Dataset.Long="Sites in selected regions with reliable PCR amplification", Dataset.Short="Final PCR")


d.FST.support_sublineage__stepbystep_combi_counts <- rbind(FST.support_sublineage.all_sites, FST.support_sublineage.retained_sites, FST.support_sublineage.final_PCR_sites)

d.FST.support_sublineage__stepbystep_combi_counts <- d.FST.support_sublineage__stepbystep_combi_counts %>%
  mutate(level2=ifelse(level=="TP_Sublineage", "Sublineage", ifelse(level=="TPA_Lineage", "Lineage", ifelse(level=="Subspecies", "Subspecies", ""))))
#filter(level == "TP_Sublineage")


p.FST.support_sublineage__stepbystep_combi_counts__barplot <- d.FST.support_sublineage__stepbystep_combi_counts %>%
  filter(level2 != "Subspecies") %>%
  mutate(Dataset.Short=factor(Dataset.Short, levels=c("All Sites","Selected Regions","Final PCR"))) %>%
  ggplot(aes(x=population, y=count, fill=population)) +
  geom_bar(stat='identity', width=0.65) + 
  facet_grid(Dataset.Short~level2, scales = 'free_x', space='free') +
  theme_bw() + theme.text.size + theme(legend.key.size = unit(0.55,"line"),legend.position='top') + 
  scale_y_continuous(breaks=pretty) +
  #coord_cartesian(ylim=c(1,100)) +
  labs(y="Discriminatory Site Count", x="Genomic Sublineage", fill="Genomic\nSublineage") +
  x.theme.axis.rotate.angle +
  scale_fill_manual(values=TP.FST_combined.cols$Color, breaks=TP.FST_combined.cols$Population_sl, name="Classification", na.value = 'grey95') + theme(legend.position = 'none') +
  y.facet.text.rotate +
  theme(strip.text.x = element_blank()) +
  geom_text(aes(x=population, y=count+7, label=count),size=text.size.within-0.5) +
  NULL

p.FST.support_sublineage__stepbystep_combi_counts__barplot

#ggsave(plot=p.FST.support_sublineage__stepbystep_combi_counts__barplot, paste0(Figures_directory,"SuppFig4__Sublin-support-in-scheme-versions.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=220, height=160, device='pdf', dpi=400)
```

\
\
\
\
\
## Compare SNP calling performance of SA AmpliSeq data with Illumina data from same regions (all variants called in regions)
ONT data called using Clair3
- Fix headers within each bcf `for i in *.sort.bcf; do bcftools annotate -O b -x FORMAT/PL $i > ${i%.sort.bcf}.ann.bcf; done`
- Index bcfs `for i in *.ann.bcf ; do bcftools index $i ; done`
- combine Clair3 ONT data `bcftools merge -0 -o TP_SA1+2+3_allsites.merge.vcf -O v *TP_Discriminatory_SA1_20230426_barcode01.clair3*.ann.bcf`
- combine with Illumina data (merged from variants.bcf generated via mm2b) `bcftools merge -0 -O b -o TP_SA1+2+3_Minion_vs_Illumina.all.2023-06-29.bcf TP_SA1+2+3_allsites.merge.bcf South-Africa_SA1+2+3-Illumina-vars.merge.bcf`
- Index new merged bcf `bcftools index TP_SA1+2+3_Minion_vs_Illumina.all.2023-06-29.bcf`
#- Restrict comparison to regions called by AmpliSeq `bcftools view -R #/data/pam/team216/mb29/scratch/Treponema/TP_Discriminatory_sites_2021/MinION_Lab_Testing/binding_sites/TP-Discriminatory-primers.design-ordered.amplicons-excl-primers.20230221.mod.bed -O v -o TP_SA1+2+3_Minion_vs_Illumina.all.2023-06-29.restrict-regions.vcf TP_SA1+2+3_Minion_vs_Illumina.all.2023-06-29.bcf`

- Restrict comparison to regions called by AmpliSeq (good regions) `/data/pam/team216/mb29/scratch/Treponema/TP_Discriminatory_sites_2021/MinION_Lab_Testing/binding_sites/TP-Discriminatory-primers.design-ordered.amplicons-excl-primers.20231201.good_amplicons.bed`
Now look at the variants called - directly compare Illumina and Nanopore variant calls within the same sites and samples

\
First, bring in contextual metadata
```{r}
#### Bring in contextual metadata

# Cleanup and process
SA.ampliseq.comparison.meta <- TP_SA.lab.metadata %>% 
  mutate(pass_both_methods=ifelse(Pass_ONT_QC=="Yes" & Pass_Illumina_QC=="Yes", "Yes", "No")) %>%
  filter(pass_both_methods=="Yes") %>%
  select(`Sample Name`, ONT_barcode, Illumina_seq) %>%
  pivot_longer(names_to="method", values_to = "readsetID", -`Sample Name`) %>%
  mutate(SeqMethod= ifelse(method=="Illumina_seq","Illumina_WGS", "ONT_PhyloSeq")) %>%
  mutate(readsetID2=ifelse(grepl("barcode",readsetID),paste0("TP_Discriminatory_",readsetID),readsetID)) %>%
  select(-method)

SA.ampliseq.comparison.meta
```

\
Bring in combined VCF file
```{r}
# File of comparative sites, filtered to only include amplicons included after quality control (i.e. based on coverage performance)
# bcf merge of Illumina and ONT-amplicon variant calls: SA.Ampliseq_vs_IlluminaWGS.vcf.file


# Import data from VCF (already processed - can use import of tables later on to speed this up)
SA.Ampliseq_vs_IlluminaWGS.vcf <- read.vcfR(SA.Ampliseq_vs_IlluminaWGS.vcf.file, verbose = FALSE )

SA.Ampliseq_vs_IlluminaWGS.tidy <- vcfR2tidy(SA.Ampliseq_vs_IlluminaWGS.vcf, single_frame = T, format_fields = c("GT"))

####
#Extract elements we want
SA.Ampliseq_vs_IlluminaWGS.df <- SA.Ampliseq_vs_IlluminaWGS.tidy$dat %>% select(CHROM,POS,ID,REF,ALT,gt_GT, gt_GT_alleles,Indiv,DP,FILTER,QUAL) %>%
  mutate(gt_GT= ifelse(gt_GT_alleles==".","0",gt_GT), gt_GT_alleles=ifelse(gt_GT_alleles==".", REF, gt_GT_alleles))

SA.Ampliseq_vs_IlluminaWGS.df

```
\
Quick analysis of raw data
```{r}
nrow(SA.Ampliseq_vs_IlluminaWGS.df)
# How many Sequences? 
distinct(SA.Ampliseq_vs_IlluminaWGS.df, Indiv) %>% nrow() 
# How many Sites? 
distinct(SA.Ampliseq_vs_IlluminaWGS.df, POS) %>% nrow() 


SA.Ampliseq_vs_IlluminaWGS.df %>% filter(grepl("TP_Discriminatory", Indiv)) %>%
  distinct(Indiv) %>% nrow()

SA.Ampliseq_vs_IlluminaWGS.df %>% filter(!grepl("TP_Discriminatory", Indiv)) %>%
  distinct(Indiv) %>% nrow()
```


\
Clean up variants and merge
```{r}
# Clean up variant calls across the two methods (bcftools for short reads and clair3 for long reads)
SA.Ampliseq_vs_IlluminaWGS.df.meta <- SA.Ampliseq_vs_IlluminaWGS.df %>% left_join(SA.ampliseq.comparison.meta, by=c("Indiv"="readsetID2")) %>%
  mutate(gt_GT_simplify= ifelse(gt_GT=="0/1","0",
                                ifelse(gt_GT=="1","1", 
                                       ifelse(gt_GT=="1/1","1",
                                              ifelse(gt_GT=="2","2",
                                                     ifelse(gt_GT=="2/2","2",
                                                            ifelse(gt_GT=="3","3",
                                                                   ifelse(gt_GT=="3/3","3",
                                                                          ifelse(gt_GT=="0/0","0", 
                                                                                 ifelse(gt_GT=="0","0", 
                                                                                        ifelse(gt_GT_alleles==".","0", NA)))))))))))
```
\
Check numbers
```{r}
nrow(SA.Ampliseq_vs_IlluminaWGS.df.meta)
distinct(SA.Ampliseq_vs_IlluminaWGS.df.meta, Indiv) %>% nrow()
distinct(SA.Ampliseq_vs_IlluminaWGS.df.meta, POS) %>% nrow()

distinct(SA.Ampliseq_vs_IlluminaWGS.df.meta, Indiv, .keep_all=T) %>%
  select(Indiv, `Sample Name`, readsetID, SeqMethod)
```
So up to this point, we have 72 AmpliSeq samples and 71 Illumina samples

\
```{r}
SA.Ampliseq_vs_IlluminaWGS.df.meta.sel <- SA.Ampliseq_vs_IlluminaWGS.df.meta %>%
  select(`Sample Name`, Indiv, SeqMethod, POS, REF, gt_GT_alleles, gt_GT, gt_GT_simplify, QUAL) %>%
  filter(!is.na(`Sample Name`))

SA.Ampliseq_vs_IlluminaWGS.df.meta.sel %>% filter(is.na(`Sample Name`)) %>% distinct(POS) %>% nrow()

SA.Ampliseq_vs_IlluminaWGS.df.meta.sel %>% filter(is.na(`Sample Name`)) %>% distinct(Indiv) %>% nrow()


SA.Ampliseq_vs_IlluminaWGS.df.meta.sel <- SA.Ampliseq_vs_IlluminaWGS.df.meta.sel %>% 
  group_by(`Sample Name`, POS) %>%
  mutate(res_per_sample.var=n()) %>%
  ungroup() %>%
  filter(POS!=1072103) %>%
  group_by(`Sample Name`, POS) %>%
  mutate(nvars.persite.persample=length(unique(gt_GT_simplify)), concordant.in.pair=ifelse(nvars.persite.persample==1,'Concordant', 'Discrepant')) %>%
  ungroup()
```

\
Now do some analysis
```{r}
# How many samples being compared? 
distinct(SA.Ampliseq_vs_IlluminaWGS.df.meta.sel, `Sample Name`) %>% nrow()

# How many sequences being compared? 
distinct(SA.Ampliseq_vs_IlluminaWGS.df.meta.sel, Indiv) %>% nrow()

# and how many sites?
distinct(SA.Ampliseq_vs_IlluminaWGS.df.meta.sel, POS) %>% nrow()

```
Ok, so we have 59 pairs remaining. On detailed investigation, this is because we had:

\
```{r ,fig.width=12, fig.height=8}
SA.Ampliseq_vs_IlluminaWGS.df.meta.sel %>% 
  select(`Sample Name`, POS, concordant.in.pair) %>%
  distinct() %>% 
  group_by(POS, concordant.in.pair) %>%
  summarise(count=n()) %>%
  ungroup() %>%
  ggplot(aes(x=factor(POS), y=count, color=concordant.in.pair)) + 
  geom_point(alpha=0.5, size=2) +
  geom_line(alpha=0.2, aes(group=POS)) +
  #geom_bar(stat='identity', position='fill') +
  theme_bw() + x.theme.axis.rotate.angle + theme.text.size


SA.Ampliseq_vs_IlluminaWGS.df.meta.sel %>% 
  select(`Sample Name`, POS, concordant.in.pair) %>%
  distinct() %>% 
  group_by(POS, concordant.in.pair) %>%
  summarise(count=n()) %>%
  ungroup() %>%
  ggplot(aes(y=factor(POS), x=count, fill=concordant.in.pair)) + 
  #geom_point(alpha=0.5, size=2) +
  #geom_line(alpha=0.2, aes(group=POS)) +
  geom_barh(stat='identity', position='fill') +
  theme_bw() + x.theme.axis.rotate.angle + theme.text.size
```
\
Examine discrepant sites
```{r}
SA.Ampliseq_vs_IlluminaWGS.df.meta.sel %>% 
  filter(concordant.in.pair=="Discrepant")

SA.Ampliseq_vs_IlluminaWGS.df.meta.sel %>% 
  filter(POS=="7002") %>%
  select(`Sample Name`, SeqMethod, POS, REF, gt_GT_alleles, concordant.in.pair) %>%
  arrange(`Sample Name`)

SA.Ampliseq_vs_IlluminaWGS.df.meta.sel %>% 
  filter(POS=="916096") %>%
  select(`Sample Name`, SeqMethod, POS, REF, gt_GT_alleles, concordant.in.pair) %>%
  arrange(`Sample Name`)
```
\
So only two Discrepancies:
\

`SA.Ampliseq_vs_IlluminaWGS.df.meta.sel %>%`
`  filter(concordant.in.pair=="Discrepant") %>% `
`  filter(POS==7002)`
`# TP_Discriminatory_SA2_20230428_barcode06 - adjacent to a homopolymeric tract? Issue affecting a single sample`

7002 - affects a single sample. However, the TG/T change is only observed in the Illumina sequence for that sample, and not in any other samples. Detailed inspection of the bam files indicates that this is a true single base deletion, and is present in both the Illumina AND the ONT reads. However, because the ONT pipeline does not look for INDELS, it has been missed by this part of the pipeline. 


`SA.Ampliseq_vs_IlluminaWGS.df.meta.sel %>%`
  `filter(concordant.in.pair=="Discrepant") %>% `
  `filter(POS==916096)`
`# TP_Discriminatory_SA1_20230426_barcode04 - very low coverage - 2/3 reads are 'T'`
`# TP_Discriminatory_SA1_20230426_barcode07 - clearly 'T', but low coverage (6 reads)`
`# Likely missed due to low coverage at site (below threshold)`


\
\
\
## Test Zimbabwe field samples (data done in field using NextFlow and Shiny App - reproduce here)
\
Analyse Zimbabwe ONT data generated and analysed in-field using the Nextflow pipeline. 
```{r}
# Zimbabwe amplicon metadata file: Zim.amplicon.metadata.file
Zim.amplicon.metadata <- read_excel(Zim.amplicon.metadata.file)

# Zimbabwe amplicon coverage directory, containing multiple files: Zim.covdata.dir
collated.cov.zim <- NULL
for (current.sample in Zim.amplicon.metadata$`Sample Name`) {
  current.cov.sample <- paste0(Zim.covdata.dir, current.sample, "_coverage_summary.tsv")
  cat("\n current_samplecov file:", current.cov.sample)
  if (file.exists(current.cov.sample))
    current.cov <- read.table(current.cov.sample, header = TRUE)
  else
    cat("\nFile", current.cov.sample, "does not exist\n")
  collated.cov.zim <- rbind(collated.cov.zim, current.cov)
}
collated.cov.zim

```
\
Plot per sample coverage
```{r, fig.height=8, fig.width=8}
collated.cov.zim %>%
  distinct(sample, name, .keep_all = T) %>%
  group_by(sample) %>%
  summarise(count=n())

p.Zim.meancov_vs_Ct__per_sample.scatter <- collated.cov.zim %>%
  left_join(Zim.amplicon.metadata, by=c("sample"="Sample Name")) %>%
  distinct(sample, name, .keep_all = T) %>% #two datasets appear to be duplicated from the nextflow run - they have very similar results, so deduplicate here
  arrange(Treponema_PolA.qPCR) %>%
  mutate(sample=factor(sample, levels=unique(sample))) %>%
  ggplot(aes(sample, depth_mean)) +
  geom_quasirandom(alpha=0.25, size=1) +
  scale_y_log10() +
  theme_bw() +
  x.theme.axis.rotate.angle +
  theme.text.size + 
  labs(y="Mean Coverage (X) per amplicon", x="Sample") +
  geom_hline(yintercept=25, color='blue', linewidth=0.5, alpha=0.8)
p.Zim.meancov_vs_Ct__per_sample.scatter <- rasterize(p.Zim.meancov_vs_Ct__per_sample.scatter, layers='Point', dpi=400)

p.Zim.meancov_vs_Ct__per_sample.scatter


p.Zim.qPCR_values.scatter <- Zim.amplicon.metadata %>%
  distinct(`Sample Name`, .keep_all = T) %>% 
  filter(Treponema_PolA.qPCR!="-") %>%
  arrange(as.numeric(Treponema_PolA.qPCR)) %>%
  mutate(`Sample Name`=factor(`Sample Name`, levels=unique(`Sample Name`))) %>%
  ggplot(aes(x=`Sample Name`, y=as.numeric(Treponema_PolA.qPCR))) +
  geom_point(size=1.5, alpha=0.7) +
  theme_bw() +
  x.theme.axis.rotate.angle +
  theme.text.size +
  labs(y="qPCR Ct")
p.Zim.qPCR_values.scatter

#x.theme.strip.labs

p.Zim.meancov_vs_Sample_vs_Ct__per_sample.combi <- plot_grid(p.Zim.qPCR_values.scatter +x.theme.strip.labs, p.Zim.meancov_vs_Ct__per_sample.scatter, ncol=1, rel_heights = c(1,4), axis="lrtb", align="v", scale=0.95)
p.Zim.meancov_vs_Sample_vs_Ct__per_sample.combi

#ggsave(plot=p.Zim.meancov_vs_Sample_vs_Ct__per_sample.combi, paste0(Figures_directory,"SuppFig13__Zim-PCR-sample-cov.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=120, height=100, device='pdf', dpi=400)
```
\
\
\
Produce stats on sequencing run readlengths (from South Africa dataset)
```{r}
# Read in filterd read lengths files

TP20230502SA.readLength.filt <- read.csv(TP20230502SA.readLength.filt.file, sep="\t", header=F, col.names = c("Sample","Read.Count","Read.Length")) %>% mutate(dataset="Filtered")
TP20230502SA.readLength.unfilt <- read.csv(TP20230502SA.readLength.unfilt.file, sep="\t", col.names = c("Sample","Read.Count","Read.Length")) %>% mutate(dataset="Unfiltered")

# Combine analyses from both runs
TP20230502SA.readLength <- rbind(TP20230502SA.readLength.filt, TP20230502SA.readLength.unfilt)
TP20230502SA.readLength$barcode <- gsub("\\.read\\-length.+$","", gsub("^.+barcode","barcode",TP20230502SA.readLength$Sample))

TP20230502SA.readLength$Sample <- gsub("TP\\_Discriminatory\\_","",gsub("\\.read\\-length.+$","", TP20230502SA.readLength$Sample))

TP20230502SA.readLength %>% group_by(dataset) %>% 
  summarise(min_length=min(Read.Length), max_length=max(Read.Length))
```

\
\
### Simulating variation in genome to evaluate capture of novel diversity
\
- generate some simulated WGS sequences on the command line at different mutation rates (use SS14 ref as a basis)
- convert to vcf
- read in and process
- filter to amplicon scheme alleles
- quantify variation in amplicons
\
\
Specify datasets
```{r}
# Folder containing simulated mutations introduced into the WGS genome: sim.WGS.mutant.folder

sim.WGS.files <- c("SS14.mutate_1.0.+ref.vcf", "SS14.mutate_0.5.+ref.vcf", "SS14.mutate_0.1.+ref.vcf", "SS14.mutate_0.05.+ref.vcf", "SS14.mutate_0.01.+ref.vcf", "SS14.mutate_0.005.+ref.vcf", "SS14.mutate_0.001.+ref.vcf", "SS14.mutate_0.0005.+ref.vcf")

paste0(sim.WGS.mutant.folder, sim.WGS.files[1])

```

\
```{r, eval=F}
#sim.dataset.vcf.file <- paste0(sim.WGS.mutant.folder, sim.WGS.files[1])

read_and_process_vcf <- function(myvcf.path){
  sim.dataset.vcf <- read.vcfR(myvcf.path, verbose = FALSE)
  sim.dataset.vcf.fix <- getFIX(sim.dataset.vcf)
  sim.dataset.vcf.fix <- data.frame(sim.dataset.vcf.fix[,c(2,4,5)], stringsAsFactors = F)
  sim.dataset.vcf.fix$Key <- 1:nrow(sim.dataset.vcf.fix)
  
  sim.dataset.vcf.gt <- extract_gt_tidy(sim.dataset.vcf)
  sim.dataset.vcf.gt.f <- plyr::join(sim.dataset.vcf.gt, sim.dataset.vcf.fix[,c("Key","POS")], by="Key", type="left")
  sim.dataset.vcf.gt.f$POS <- as.numeric(sim.dataset.vcf.gt.f$POS)
  sim.dataset.vcf.gt.f$gt_GT <- as.numeric(sim.dataset.vcf.gt.f$gt_GT)
  return(sim.dataset.vcf.gt.f)
}

######
# SS14.mutate_1.0_sim <- read_and_process_vcf(paste0(sim.WGS.mutant.folder, sim.WGS.files[1])) # these are VERY big files, and have so many SNPs that they don't really add anything
# SS14.mutate_0.5_sim <- read_and_process_vcf(paste0(sim.WGS.mutant.folder, sim.WGS.files[2]))  # these are VERY big files, and have so many SNPs that they don't really add anything
SS14.mutate_0.1_sim <- read_and_process_vcf(paste0(sim.WGS.mutant.folder, sim.WGS.files[3]))
SS14.mutate_0.05_sim <- read_and_process_vcf(paste0(sim.WGS.mutant.folder, sim.WGS.files[4]))
SS14.mutate_0.01_sim <- read_and_process_vcf(paste0(sim.WGS.mutant.folder, sim.WGS.files[5]))
SS14.mutate_0.005_sim <- read_and_process_vcf(paste0(sim.WGS.mutant.folder, sim.WGS.files[6]))
SS14.mutate_0.001_sim <- read_and_process_vcf(paste0(sim.WGS.mutant.folder, sim.WGS.files[7]))
SS14.mutate_0.0005_sim <- read_and_process_vcf(paste0(sim.WGS.mutant.folder, sim.WGS.files[8]))
```
\
Write out files
```{r, eval=F}
# Write processed files to csv, so they can be reimported
write.csv(SS14.mutate_0.1_sim, file=paste0(sim.WGS.mutant.folder, sim.WGS.files[3],".tsv"), row.names = F, quote=F)
write.csv(SS14.mutate_0.05_sim, file=paste0(sim.WGS.mutant.folder, sim.WGS.files[4],".tsv"), row.names = F, quote=F)
write.csv(SS14.mutate_0.01_sim, file=paste0(sim.WGS.mutant.folder, sim.WGS.files[5],".tsv"), row.names = F, quote=F)
write.csv(SS14.mutate_0.005_sim, file=paste0(sim.WGS.mutant.folder, sim.WGS.files[6],".tsv"), row.names = F, quote=F)
write.csv(SS14.mutate_0.001_sim, file=paste0(sim.WGS.mutant.folder, sim.WGS.files[7],".tsv"), row.names = F, quote=F)
write.csv(SS14.mutate_0.0005_sim, file=paste0(sim.WGS.mutant.folder, sim.WGS.files[8],".tsv"), row.names = F, quote=F)
```
\
```{r, eval=F}
# Read files back in
SS14.mutate_0.1_sim <- read.csv(file=paste0(sim.WGS.mutant.folder, sim.WGS.files[3],".tsv"), row.names = F, quote=F)
SS14.mutate_0.05_sim <- read.csv(file=paste0(sim.WGS.mutant.folder, sim.WGS.files[4],".tsv"))
SS14.mutate_0.01_sim <- read.csv(file=paste0(sim.WGS.mutant.folder, sim.WGS.files[5],".tsv"))
SS14.mutate_0.005_sim <- read.csv(file=paste0(sim.WGS.mutant.folder, sim.WGS.files[6],".tsv"))
SS14.mutate_0.001_sim <- read.csv(file=paste0(sim.WGS.mutant.folder, sim.WGS.files[7],".tsv"))
SS14.mutate_0.0005_sim <- read.csv(file=paste0(sim.WGS.mutant.folder, sim.WGS.files[8],".tsv"))
```


Filter sites to those in the amplicons
```{r}
# Function to find sites within amplicons
extract_SNPs_in_amplicons <- function(my.SNPsites){
  # Create IRanges object from sites
  current.SNPsites.IRanges <- IRanges(start=my.SNPsites, end=my.SNPsites, name=as.character(my.SNPsites))
  # test if there are any intersects - if there are, run a bunch of analyses, if there are not, generate an empty file
  if(nrow(data.frame(IRanges::findOverlaps(current.SNPsites.IRanges, SS14.insert.sites__goodregions.IRanges, select="all"))) >=1){
    # find overlaps with primer scheme amplicons
    current.SNPsites__IRanges_overlap_with_good_primers <- data.frame(IRanges::findOverlaps(current.SNPsites.IRanges, SS14.insert.sites__goodregions.IRanges, select="all"))
    # Add amplicon overlap names
    current.SNPsites__IRanges_overlap_with_good_primers$amplicons <- sapply(1:length(current.SNPsites__IRanges_overlap_with_good_primers$subjectHits), function(x) primalscheme.designs.SS14.binding_sites_full.table__subset.good_amplicons$amplicon[current.SNPsites__IRanges_overlap_with_good_primers$subjectHits[x]])
    # add SNP positions
    current.SNPsites__IRanges_overlap_with_good_primers$SNP_Pos <- sapply(1:length(current.SNPsites__IRanges_overlap_with_good_primers$queryHits), function(x) my.SNPsites[current.SNPsites__IRanges_overlap_with_good_primers$queryHits[x]])
    current.SNPsites__IRanges_overlap_with_good_primers$true.snp <- 1
  }
  else {
    current.SNPsites__IRanges_overlap_with_good_primers <- data.frame(queryHits=0, subjectHits=0, amplicons=0, SNP_Pos=0, true.snp=0)
  }
  return(current.SNPsites__IRanges_overlap_with_good_primers)
}
```
\

```{r, eval=FALSE}
# All variable positions
extract_SNPs_in_amplicons(unique(SS14.mutate_0.01_sim$POS))

extract_SNPs_in_amplicons(unique(SS14.mutate_0.0005_sim$POS))

# per sample
extract_SNPs_in_amplicons( SS14.mutate_0.01_sim %>%
  filter(Indiv=="NC_021508_1_1_mutated_100") %>%
  filter(gt_GT!=0 & gt_GT_alleles!="*") %>%
  pull(POS) )
```

\
\
Need to find SNPs within amplicons using the simulated data
```{r}
# Function to count sites sitting within amplicons, using a loop to evaluate each replicate 
count_sites_in_amplicons__loop <- function(sim.data) {
  collate.site.overlap.accross.replicates <- NULL
  for (current.sample in filter(sim.data, Indiv!="NC_021508_1_1") %>% distinct(Indiv) %>% pull() ) {
    # Extract sites for current samples
    current.sitelist <- sim.data %>%
      filter(Indiv==current.sample) %>%
      filter(gt_GT!=0 & gt_GT_alleles!="*") %>%
      distinct(POS) %>%
      pull(POS) 
    if (length(current.sitelist)==0){
      current.site.count <- data.frame(sample=current.sample, SNP.count=0)
    } 
    else {
      current.site.overlap <- extract_SNPs_in_amplicons(current.sitelist)
      #current.site.count <- data.frame(sample=current.sample, SNP.count=nrow(current.site.overlap))  
      current.site.count <- data.frame(sample=current.sample, SNP.count=sum(current.site.overlap$true.snp)) 
    }
    collate.site.overlap.accross.replicates <- rbind(collate.site.overlap.accross.replicates, current.site.count) 
  }
  return(collate.site.overlap.accross.replicates)
}

```

\
run with all sims (exclude 1% and 0.5%, since there are so many mutations it's irrelevant)
```{r, eval=F}
# SS14.mutate_1.0_sim.amplicon_site_counts <- count_sites_in_amplicons__loop(SS14.mutate_1.0_sim) %>%
#   mutate(sim="1.0")
# 
# SS14.mutate_0.5_sim.amplicon_site_counts <- count_sites_in_amplicons__loop(SS14.mutate_0.5_sim) %>%
#   mutate(sim="0.5")

SS14.mutate_0.1_sim.amplicon_site_counts <- count_sites_in_amplicons__loop(SS14.mutate_0.1_sim) %>% 
  mutate(sim="0.1")

SS14.mutate_0.05_sim.amplicon_site_counts <- count_sites_in_amplicons__loop(SS14.mutate_0.05_sim) %>%
  mutate(sim="0.05")

SS14.mutate_0.01_sim.amplicon_site_counts <- count_sites_in_amplicons__loop(SS14.mutate_0.01_sim) %>%
  mutate(sim="0.01")

SS14.mutate_0.005_sim.amplicon_site_counts <- count_sites_in_amplicons__loop(SS14.mutate_0.005_sim) %>%
  mutate(sim="0.005")

SS14.mutate_0.001_sim.amplicon_site_counts <- count_sites_in_amplicons__loop(SS14.mutate_0.001_sim) %>%
  mutate(sim="0.001")

SS14.mutate_0.0005_sim.amplicon_site_counts <- count_sites_in_amplicons__loop(SS14.mutate_0.0005_sim) %>%
  mutate(sim="0.0005")


SS14.mutate_sim.amplicon_site_counts__collated <- rbind(SS14.mutate_0.1_sim.amplicon_site_counts, SS14.mutate_0.05_sim.amplicon_site_counts, SS14.mutate_0.01_sim.amplicon_site_counts, SS14.mutate_0.005_sim.amplicon_site_counts, SS14.mutate_0.001_sim.amplicon_site_counts, SS14.mutate_0.0005_sim.amplicon_site_counts)

#write.csv(SS14.mutate_sim.amplicon_site_counts__collated, file=paste0(sim.WGS.mutant.folder, "SS14.mutate_sim.amplicon_site_counts__collated.csv"), row.names = F, quote=F)
```
\
Read file back in (fastest to use precalculated data)
```{r}
# Collated precalculated SNP count data in simulated amplicons
# paste0(sim.WGS.mutant.folder, "SS14.mutate_sim.amplicon_site_counts__collated.csv")


SS14.mutate_sim.amplicon_site_counts__collated <- read.csv(paste0(sim.WGS.mutant.folder, "SS14.mutate_sim.amplicon_site_counts__collated.csv"))
```

\
analyse and plot
```{r}
SS14.mutate_sim.amplicon_site_counts__collated %>%
  ggplot(aes(as.numeric(SNP.count), group=sim, color=factor(sim))) +
  geom_density() + 
  scale_x_continuous(breaks=seq(0,max(SS14.mutate_sim.amplicon_site_counts__collated$SNP.count),2)) + 
  #scale_y_log10() +
  theme_bw() + theme.text.size +
  labs(y="Replicates", x="SNP count in amplicons") 


p.simulated_mutations_in_amplicons <- SS14.mutate_sim.amplicon_site_counts__collated %>%
  mutate(sim.perc = paste0(sim, " %")) %>%
  mutate(sim.perc.count = paste0(sim, "%", " (",round(1139569*(sim/100),0)," WGS SNPs)")) %>%
  #group_by(sample, sim, SNP.count) %>%
  #summarise(count=n())
  ggplot(aes(SNP.count)) +
  geom_histogram(binwidth = 1) + 
  scale_x_continuous(breaks=seq(0,max(SS14.mutate_sim.amplicon_site_counts__collated$SNP.count),1)) + 
  theme_bw() + theme.text.size +
  labs(y="Replicates", x="Simulated SNPs within amplicons") +
  #facet_grid(sim.perc~., scales="free_y") + y.facet.text.rotate +
  #facet_wrap(vars(sim.perc), scales="free_y") + #y.facet.text.rotate +
  facet_wrap(vars(sim.perc.count), ncol=2) + #y.facet.text.rotate +
  scale_x_continuous(breaks=pretty) +
  scale_x_continuous(sec.axis = sec_axis(~ . , name = "% genomic sites mutated", labels = NULL, breaks = NULL)) +
  geom_vline(xintercept=2, linewidth=0.25, color='blue')
p.simulated_mutations_in_amplicons


#ggsave(plot=p.simulated_mutations_in_amplicons, paste0(Figures_directory,"SuppFig14__Simulate-mutational-freqs.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=180, height=180, device='pdf', dpi=400)
```

\
Quantify proportion above 2 SNPs (effectively needed to see something different in AmpliSeq)
```{r}
d.SS14.mutate_sim.amplicon_site_counts__summarised <-  SS14.mutate_sim.amplicon_site_counts__collated %>%
  group_by(sim, SNP.count) %>%
  summarise(rep.count=n()) %>%
  mutate(total=sum(rep.count), rep.perc=round((rep.count/total)*100, 1)) %>%
  mutate(is.over2=ifelse(SNP.count>=2, 'yes', 'no')) %>%
  group_by(sim, is.over2) %>%
  mutate(over2.count=sum(rep.count), over2.perc=round((over2.count/total)*100, 1))

d.SS14.mutate_sim.amplicon_site_counts__summarised
```
\
Plot 2 SNP recovery - this?
```{r}
d.SS14.mutate_sim.amplicon_site_counts__summarised %>% 
  distinct(sim, is.over2, .keep_all = T) %>%
  filter(is.over2=="yes") %>%
  ggplot(aes(x=sim, y=over2.perc)) +
  geom_point() +
  theme_bw() + theme.text.size +
  scale_x_log10() +
  labs(y="% replicates ≥2 SNPs", x="WGS mutation frequency (%)") +
  #stat_smooth(method = 'nls', formula = y ~ a*exp(b *x), se = FALSE, start = list(a=0.0001,b=0.0001)) +
  #stat_smooth(method = 'nls', formula = y ~ a*exp(b *x), se = FALSE) +
  #geom_smooth(method='lm') +
  NULL
```

\
\
What about examining the effect of different target regions on cluster formation. We have used 300bp because it worked well using ad hoc testing, but we should formally test other region sizes. 

```{r}

FST.sublin.combined.sig.unique.sites.combo.near_100 <- make_genome_site_positional_matrix(100)


genomic.sites.network_100bp <- make_positional_network(FST.sublin.combined.sig.unique.sites.combo.near_100)

genomic.sites.network_100bp.gg <- prepare_networkgg_for_plotting(genomic.sites.network_100bp)



# Run analysis in a loop to assess impact of changing cluster size
genomic_positional_distance_clustering_collated <- setNames(data.frame(matrix(ncol = 4, nrow = 0)), c("region.cluster", "SNPs.per.cluster", "region.distance", "linkage.dist"))

for (current.size in seq(50,1000, 50)){
  # Generate network
  FST.sublin.combined.sig.unique.sites.combo.near__current <- make_genome_site_positional_matrix(current.size)
  genomic.sites.network_current <- make_positional_network(FST.sublin.combined.sig.unique.sites.combo.near__current)
  # Get cluster info and link
  genomic.sites.network_current.gg <- prepare_networkgg_for_plotting(genomic.sites.network_current) 
  # extract key stats on network components
  genomic.sites.network_current.gg <- genomic.sites.network_current.gg %>%
    group_by(region.cluster) %>%
    mutate(SNPs.per.cluster=length(unique(vertex.names))) %>%
    mutate(vertex.pos=as.numeric(gsub("s","",vertex.names))) %>%
    mutate(region.start=min(vertex.pos), region.end=max(vertex.pos), region.distance=region.end-region.start) %>%
    ungroup() 
    # Create summary df that contains the key info we need
    summarise.sites.network.info <- genomic.sites.network_current.gg %>% 
      mutate(linkage.dist=current.size) %>%
      select(region.cluster, SNPs.per.cluster, region.distance, linkage.dist) %>%
      distinct()
   
  genomic_positional_distance_clustering_collated <- rbind(summarise.sites.network.info, genomic_positional_distance_clustering_collated)
}
  
genomic_positional_distance_clustering_collated

```

\
Plot
```{r, fig.height=6, fig.width=6}
p.genomic_positional_distance_clustering_Clustercount <- genomic_positional_distance_clustering_collated %>%
  group_by(linkage.dist) %>%
  summarise(cluster.count = n()) %>%
  ggplot(aes(x=linkage.dist, y=cluster.count)) +
  geom_point(alpha=0.5, size=1) + 
  theme_bw() + theme.text.size +
  scale_x_continuous(breaks=seq(0,max(genomic_positional_distance_clustering_collated$linkage.dist), 100)) +
  scale_y_continuous(breaks=pretty) +
  coord_cartesian(ylim=c(0,350)) +
  x.theme.axis.rotate.angle +
  labs(x="Cluster linkage size (bp)", y="Cluster count")

p.genomic_positional_distance_clustering_SNPcount <- genomic_positional_distance_clustering_collated %>%
  ggplot(aes(x=linkage.dist, y=SNPs.per.cluster)) +
  rasterise(geom_quasirandom(size=0.5, alpha=0.5), dpi=400) + 
  theme_bw() + theme.text.size +
  scale_x_continuous(breaks=seq(0,max(genomic_positional_distance_clustering_collated$linkage.dist), 100)) +
  scale_y_continuous(breaks=pretty) +
  x.theme.axis.rotate.angle +
  labs(x="Cluster linkage size (bp)", y="SNPs/Amplicon")


p.genomic_positional_distance_clustering_regiondist <- genomic_positional_distance_clustering_collated %>%
  ggplot(aes(x=linkage.dist, y=region.distance)) +
  rasterise(geom_quasirandom(size=0.5, alpha=0.5), dpi=400) + 
  theme_bw() + theme.text.size +
  scale_x_continuous(breaks=seq(0,max(genomic_positional_distance_clustering_collated$linkage.dist), 100)) +
  scale_y_continuous(breaks=pretty) +
  scale_y_log10() + coord_cartesian(ylim=c(1,max(genomic_positional_distance_clustering_collated$region.distance))) +
  x.theme.axis.rotate.angle +
  labs(x="Cluster linkage size (bp)", y="Length of region\nspanning SNPs (bp)")

# Combination plot
p.genomic_positional_distance_clustering__combi <- plot_grid(p.genomic_positional_distance_clustering_Clustercount + x.theme.strip, p.genomic_positional_distance_clustering_SNPcount + x.theme.strip, p.genomic_positional_distance_clustering_regiondist, ncol=1, align="v", rel_heights = c(2,3,4), label_size = 11, labels = "AUTO")

p.genomic_positional_distance_clustering__combi


#ggsave(plot=p.genomic_positional_distance_clustering__combi, paste0(Figures_directory,"SuppFig6__Linkage-distance-impact.",format(Sys.Date(),"%Y%m%d"),".pdf"), units='mm', width=180, height=180, device='pdf', dpi=400) 

```


\
\
## Supplementary Data table prep
Make a nice prettier summary table of the amplicons and primers for a supplementary data table
```{r, eval=F}
primalscheme.design.summary <- primalscheme.design %>%
  select(region, primer_side, X.gc, tm..use.65., size, seq) %>%
  mutate(primer_dir=ifelse(primer_side=="LEFT","FWD","REV")) %>% select(-primer_side) %>%
  mutate(primer.length=size) %>% select(-size) %>%
  mutate(primer.GC=X.gc) %>% select(-X.gc) %>%
  mutate(primer.Tm=tm..use.65.) %>% select(-tm..use.65.) %>%
  pivot_wider(names_from=primer_dir, values_from =  c(primer.length,primer.Tm,primer.GC,seq)) %>%
  left_join(SS14.primer_binding.locations, by=c("region"="pcr.region")) %>%
  filter(!is.na(refgenome)) %>% 
  mutate(final.scheme=ifelse(region %in% primalscheme.designs.SS14.binding_sites_full.table.good$amplicon, "yes","no")) %>% 
  mutate(region=gsub("all_","region_", region)) %>% 
  mutate(amplicon.length=amplicon.end-amplicon.start) %>%
  select(region, final.scheme,refgenome,amplicon.start,amplicon.end,amplicon.length,seq_FWD,seq_REV,primer.Tm_FWD,primer.Tm_REV,primer.GC_FWD,primer.GC_REV,primer.length_FWD,primer.length_REV)
#primalscheme.design.summary

# need to add 23S
primalscheme.design.summary.23S <- primalscheme.design.23S %>% 
  select(amplicon, SS14_Pos_1, primer.side, X.gc, tm..use.65., size, seq) %>%
  mutate(primer_dir=ifelse(primer.side=="LEFT","FWD","REV")) %>% select(-primer.side) %>%
  mutate(primer.length=size) %>% select(-size) %>%
  mutate(primer.GC=X.gc) %>% select(-X.gc) %>%
  mutate(primer.Tm=tm..use.65.) %>% select(-tm..use.65.) %>%
  pivot_wider(names_from=primer_dir, values_from =  c(primer.length,primer.Tm,primer.GC,seq,SS14_Pos_1)) %>%
  mutate(amplicon.start=SS14_Pos_1_FWD, amplicon.end=SS14_Pos_1_REV) %>%
  mutate(region=amplicon) %>%
  mutate(final.scheme= ifelse(region=="23S_scheme_1", "yes","no")) %>%
  mutate(refgenome="NC_021508_1_1") %>%
  mutate(amplicon.length=amplicon.end-amplicon.start) %>%
  select(region, final.scheme,refgenome,amplicon.start,amplicon.end,amplicon.length,seq_FWD,seq_REV,primer.Tm_FWD,primer.Tm_REV,primer.GC_FWD,primer.GC_REV,primer.length_FWD,primer.length_REV)
#primalscheme.design.summary.23S

primalscheme.design.summary_all <- rbind(primalscheme.design.summary, primalscheme.design.summary.23S)

primalscheme.design.summary_all

#write.csv(primalscheme.design.summary_all, file=paste0(Data_input_directory, "SuppTable2__Amplicon_Primer_details.csv"), row.names = F)

```
\
Basic stats on primers
```{r}
primalscheme.design.summary_all %>%
  summarise(mean.length= mean(amplicon.length), 
            min.length= min(amplicon.length), 
            max.length= max(amplicon.length))
```



\




